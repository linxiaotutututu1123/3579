"""CTP行情网关实现

实现基于CTP接口的行情网关，负责连接CTP服务器、订阅行情、
处理数据转换和发布等功能。
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime

from src.market_gateway.base import MarketGateway, GatewayStatus
from src.market_gateway.events import EventType, TickDataEvent
from src.market_gateway.exceptions import (
    ConnectionError,
    SubscriptionError,
    ConfigError,
    DataValidationError
)
from src.models.tick_data import TickData
from src.config.gateway_config import GatewayConfig

# 假设这是CTP接口的Python封装
# from ctp_api import CThostFtdcMdApi

logger = logging.getLogger(__name__)


class CtpMarketGateway(MarketGateway):
    """CTP行情网关实现"""
    
    def __init__(self, config: Dict[str, Any]):
        """初始化CTP行情网关
        
        Args:
            config: 网关配置字典
            
        Raises:
            ConfigError: 配置无效时抛出
        """
        super().__init__(config)
        try:
            self.gateway_config = GatewayConfig(**config)
        except Exception as e:
            raise ConfigError(f"Invalid gateway configuration: {str(e)}")
        
        # CTP API实例
        self.api = None  # CThostFtdcMdApi.CreateFtdcMdApi()
        
        # 连接状态
        self.request_id = 0
        self.connected = False
        self.logged_in = False
        
        # 订阅管理
        self.subscribed_symbols: set = set()
        self.subscription_lock = asyncio.Lock()
        
        # 重连管理
        self.reconnect_attempts = 0
        self.should_reconnect = True
        
        logger.info(f"Initialized CtpMarketGateway: {self.gateway_config.name}")

    async def connect(self) -> bool:
        """连接到CTP行情服务器
        
        Returns:
            bool: 连接是否成功
            
        Raises:
            ConnectionError: 连接失败
            TimeoutError: 连接超时
            ConfigError: 配置错误
        """
        if not self.gateway_config.enabled:
            logger.warning("Gateway is disabled, skipping connection")
            return False
            
        try:
            ctp_config = self.gateway_config.ctp
            
            # 更新状态
            self.status = GatewayStatus.CONNECTING
            logger.info(f"Connecting to CTP server: {ctp_config.front_addr}")
            
            # 初始化API
            # self.api.RegisterSpi(self)
            # self.api.RegisterFront(ctp_config.front_addr)
            # self.api.Init()
            
            # 等待连接建立
            # await self._wait_for_condition(lambda: self.connected, 
            #                               timeout=ctp_config.connect_timeout)
            
            # 登录认证
            # success = await self._login()
            # if not success:
            #     raise AuthenticationError("Failed to authenticate with CTP server")
            
            self.status = GatewayStatus.CONNECTED
            self.reconnect_attempts = 0
            logger.info("Successfully connected to CTP server")
            return True
            
        except Exception as e:
            self.status = GatewayStatus.ERROR
            logger.error(f"Failed to connect to CTP server: {str(e)}")
            raise ConnectionError(f"Connection failed: {str(e)}")

    async def _login(self) -> bool:
        """登录到CTP服务器
        
        Returns:
            bool: 登录是否成功
        """
        # 这里应该是实际的登录逻辑
        # req = {
        #     "BrokerID": self.gateway_config.ctp.broker_id,
        #     "UserID": self.gateway_config.ctp.user_id,
        #     "Password": self.gateway_config.ctp.password,
        #     "AppID": self.gateway_config.ctp.app_id or "",
        #     "AuthCode": self.gateway_config.ctp.auth_code or ""
        # }
        # 
        # self.request_id += 1
        # return self.api.ReqUserLogin(req, self.request_id)
        return True  # 临时返回True

    async def subscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """订阅合约行情

        Args:
            symbols: 合约代码列表

        Returns:
            Dict[str, bool]: 合约代码到订阅结果的映射

        Raises:
            SubscriptionError: 订阅失败
        """
        if not symbols:
            logger.warning("No symbols provided for subscription")
            return {}

        async with self.subscription_lock:
            try:
                result: Dict[str, bool] = {}

                # 过滤已订阅的合约
                new_symbols = [s for s in symbols if s not in self.subscribed_symbols]

                # 已订阅的标记为成功
                for s in symbols:
                    if s in self.subscribed_symbols:
                        result[s] = True

                if not new_symbols:
                    logger.info("All symbols already subscribed")
                    return result

                # 检查订阅限制
                if len(self.subscribed_symbols) + len(new_symbols) > self.gateway_config.max_subscriptions:
                    raise SubscriptionError(
                        f"Subscription limit exceeded: {self.gateway_config.max_subscriptions}"
                    )

                # 执行订阅
                # api_result = self.api.SubscribeMarketData(new_symbols)
                # if not api_result:
                #     raise SubscriptionError("Failed to subscribe to market data")

                # 更新订阅列表
                for s in new_symbols:
                    self.subscribed_symbols.add(s)
                    result[s] = True

                logger.info(f"Subscribed to symbols: {new_symbols}")

                # 触发订阅事件
                await self.emit_event(EventType.SUBSCRIBED.value, {"symbols": new_symbols})

                return result

            except Exception as e:
                logger.error(f"Failed to subscribe to symbols {symbols}: {str(e)}")
                raise SubscriptionError(f"Subscription failed: {str(e)}")

    async def unsubscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """取消订阅合约行情

        Args:
            symbols: 合约代码列表

        Returns:
            Dict[str, bool]: 合约代码到取消订阅结果的映射

        Raises:
            SubscriptionError: 取消订阅失败
        """
        if not symbols:
            logger.warning("No symbols provided for unsubscription")
            return {}

        async with self.subscription_lock:
            try:
                result: Dict[str, bool] = {}

                # 过滤未订阅的合约
                subscribed_to_remove = [s for s in symbols if s in self.subscribed_symbols]

                # 未订阅的标记为成功（无需取消）
                for s in symbols:
                    if s not in self.subscribed_symbols:
                        result[s] = True

                if not subscribed_to_remove:
                    logger.info("No symbols to unsubscribe")
                    return result

                # 执行取消订阅
                # api_result = self.api.UnSubscribeMarketData(subscribed_to_remove)
                # if not api_result:
                #     raise SubscriptionError("Failed to unsubscribe from market data")

                # 更新订阅列表
                for s in subscribed_to_remove:
                    self.subscribed_symbols.discard(s)
                    result[s] = True

                logger.info(f"Unsubscribed from symbols: {subscribed_to_remove}")

                # 触发取消订阅事件
                await self.emit_event(EventType.UNSUBSCRIBED.value, {"symbols": subscribed_to_remove})

                return result

            except Exception as e:
                logger.error(f"Failed to unsubscribe from symbols {symbols}: {str(e)}")
                raise SubscriptionError(f"Unsubscription failed: {str(e)}")

    async def on_tick(self, ctp_data: Dict[str, Any]) -> Optional[TickData]:
        """处理CTP格式的Tick数据
        
        Args:
            ctp_data: CTP格式的行情数据
            
        Returns:
            TickData: 标准化的Tick数据对象，如果数据无效则返回None
        """
        try:
            # 数据清洗和验证
            cleaned_data = self._clean_tick_data(ctp_data)
            if not cleaned_data:
                logger.debug(f"Invalid tick data filtered: {ctp_data}")
                return None
            
            # 转换为标准TickData对象
            tick_data = self._convert_to_tick_data(cleaned_data)
            
            # 数据验证
            if not tick_data.is_valid:
                logger.warning(f"Invalid tick data: {tick_data}")
                return None
            
            # 发布事件
            event = TickDataEvent(
                event_type=EventType.TICK_DATA,
                timestamp=datetime.now(),
                source=self.gateway_config.name,
                data=tick_data,
                symbol=tick_data.symbol,
                tick_data=tick_data.model_dump()
            )
            await self.emit_event(EventType.TICK_DATA.value, event)
            
            return tick_data
            
        except DataValidationError as e:
            logger.warning(f"Data validation error: {str(e)}")
            return None
        except Exception as e:
            logger.error(f"Error processing tick data: {str(e)}")
            return None

    def _clean_tick_data(self, ctp_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """清洗CTP格式的Tick数据
        
        Args:
            ctp_data: 原始CTP数据
            
        Returns:
            Dict: 清洗后的数据，如果数据无效则返回None
        """
        try:
            # 检查基本字段
            required_fields = ["InstrumentID", "ExchangeID", "LastPrice", "Volume"]
            for field in required_fields:
                if field not in ctp_data or ctp_data[field] is None:
                    logger.debug(f"Missing required field: {field}")
                    return None
            
            # 价格验证
            last_price = float(ctp_data.get("LastPrice", 0))
            if last_price <= 0:
                logger.debug(f"Invalid last price: {last_price}")
                return None
            
            # 成交量验证
            volume = int(ctp_data.get("Volume", 0))
            if volume < 0:
                logger.debug(f"Invalid volume: {volume}")
                return None
            
            # 时间戳处理
            update_time = ctp_data.get("UpdateTime", "")
            trading_day = ctp_data.get("TradingDay", "")

            if not update_time or not trading_day:
                logger.debug("Missing timestamp information")
                return None

            # 构造完整时间戳（如需启用，取消下面注释）
            # update_millisec = ctp_data.get("UpdateMillisec", 0)
            # datetime_str = f"{trading_day} {update_time}.{update_millisec:03d}"
            # dt = datetime.strptime(datetime_str, "%Y%m%d %H:%M:%S.%f")
            
            # 数据正常，返回清洗后的数据
            cleaned = ctp_data.copy()
            # cleaned["datetime"] = dt
            # cleaned["local_datetime"] = datetime.now()
            
            return cleaned
            
        except Exception as e:
            logger.error(f"Error cleaning tick data: {str(e)}")
            return None

    def _convert_to_tick_data(self, ctp_data: Dict[str, Any]) -> TickData:
        """将CTP数据转换为标准TickData对象
        
        Args:
            ctp_data: 清洗后的CTP数据
            
        Returns:
            TickData: 标准化的Tick数据对象
        """
        # 这里应该是实际的数据转换逻辑
        tick_dict = {
            "symbol": ctp_data["InstrumentID"],
            "exchange": ctp_data["ExchangeID"],
            "datetime": datetime.now(),  # 实际应该是ctp_data["datetime"]
            "local_datetime": datetime.now(),
            "last_price": Decimal(str(ctp_data["LastPrice"])),
            "volume": int(ctp_data.get("Volume", 0)),
            "turnover": Decimal(str(ctp_data.get("Turnover", 0))),
            "open_interest": int(ctp_data.get("OpenInterest", 0)),
            "bid_price_1": Decimal(str(ctp_data.get("BidPrice1", 0))),
            "ask_price_1": Decimal(str(ctp_data.get("AskPrice1", 0))),
            "bid_volume_1": int(ctp_data.get("BidVolume1", 0)),
            "ask_volume_1": int(ctp_data.get("AskVolume1", 0)),
        }
        
        return TickData(**tick_dict)

    async def reconnect(self) -> bool:
        """执行重连操作，使用指数退避策略

        Returns:
            bool: 重连是否成功
        """
        if not self.should_reconnect:
            logger.info("Reconnection disabled, skipping")
            return False

        backoff = self.gateway_config.initial_backoff_seconds
        max_attempts = self.gateway_config.max_reconnect_attempts
        # max_attempts=0 表示无限重连
        unlimited = (max_attempts == 0)

        while unlimited or self.reconnect_attempts < max_attempts:
            try:
                self.status = GatewayStatus.RECONNECTING
                self.reconnect_attempts += 1
                if unlimited:
                    logger.info(f"Reconnection attempt {self.reconnect_attempts} (unlimited)")
                else:
                    logger.info(f"Reconnection attempt {self.reconnect_attempts}/{max_attempts}")

                # 尝试连接
                if await self.connect():
                    logger.info("Reconnection successful")
                    # 重新订阅之前的合约
                    if self.subscribed_symbols:
                        await self.subscribe(list(self.subscribed_symbols))
                    return True

            except Exception as e:
                logger.warning(f"Reconnection attempt {self.reconnect_attempts} failed: {str(e)}")

                # 检查是否达到最大重连次数
                if not unlimited and self.reconnect_attempts >= max_attempts:
                    logger.error("Max reconnection attempts reached")
                    self.status = GatewayStatus.ERROR
                    break

                # 等待退避时间
                logger.info(f"Waiting {backoff} seconds before next attempt")
                await asyncio.sleep(backoff)

                # 指数退避
                backoff = min(backoff * 2, self.gateway_config.max_backoff_seconds)
        
        return False

    async def disconnect(self) -> None:
        """断开与CTP服务器的连接

        Raises:
            ConnectionError: 断开连接失败
        """
        try:
            self.should_reconnect = False

            if self.api:
                # self.api.Release()
                self.api = None

            self.status = GatewayStatus.DISCONNECTED
            self.connected = False
            self.logged_in = False
            logger.info("Disconnected from CTP server")

        except Exception as e:
            logger.error(f"Error disconnecting from CTP server: {str(e)}")
            raise ConnectionError(f"Disconnect failed: {str(e)}")

    def __repr__(self) -> str:
        """返回网关的字符串表示"""
        return (f"CtpMarketGateway(name={self.gateway_config.name}, "
                f"status={self.status.value}, "
                f"subscribed_symbols={len(self.subscribed_symbols)})")


__all__ = ['CtpMarketGateway']