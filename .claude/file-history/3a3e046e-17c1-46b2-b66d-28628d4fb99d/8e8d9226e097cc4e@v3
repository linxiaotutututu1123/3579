"""
行情网关抽象基类和核心接口

提供统一的网关接口定义，支持多种行情源（CTP、IB等）。
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Callable, Awaitable, Optional, Set
from enum import Enum
from dataclasses import dataclass, field
import asyncio
import logging

logger = logging.getLogger(__name__)


class GatewayStatus(Enum):
    """网关状态枚举

    Attributes:
        DISCONNECTED: 已断开连接
        CONNECTING: 正在连接
        CONNECTED: 已连接
        RECONNECTING: 正在重连
        ERROR: 错误状态
        STOPPED: 已停止
    """
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    RECONNECTING = "reconnecting"
    ERROR = "error"
    STOPPED = "stopped"


@dataclass
class ConnectionInfo:
    """连接信息数据类

    存储网关连接的基本信息。

    Attributes:
        host: 主机地址
        port: 端口号
        username: 用户名
        password: 密码（注意：生产环境应加密存储）
        extra_params: 额外连接参数
    """
    host: str
    port: int
    username: str = ""
    password: str = ""
    extra_params: Dict[str, Any] = field(default_factory=dict)

    def __repr__(self) -> str:
        """返回连接信息的字符串表示（隐藏密码）"""
        return (f"ConnectionInfo(host={self.host}, port={self.port}, "
                f"username={self.username}, password=****)")

    def to_dict(self, include_password: bool = False) -> Dict[str, Any]:
        """转换为字典

        Args:
            include_password: 是否包含密码

        Returns:
            Dict[str, Any]: 连接信息字典
        """
        result = {
            "host": self.host,
            "port": self.port,
            "username": self.username,
            "extra_params": self.extra_params
        }
        if include_password:
            result["password"] = self.password
        return result


# 事件处理器类型别名
EventHandler = Callable[[Any], Awaitable[None]]


class MarketGateway(ABC):
    """行情网关抽象基类

    为所有行情网关提供统一的接口定义。支持CTP、IB等多种行情源。

    使用示例:
        class MyGateway(MarketGateway):
            async def connect(self) -> bool:
                # 实现连接逻辑
                pass

        gateway = MyGateway(config)
        await gateway.connect()
        await gateway.subscribe(["rb2401", "cu2401"])
    """

    def __init__(self, config: Dict[str, Any]):
        """初始化网关

        Args:
            config: 网关配置字典，包含连接参数等信息
        """
        self.config = config
        self.status = GatewayStatus.DISCONNECTED
        self.subscribed_symbols: Set[str] = set()
        self.event_handlers: Dict[str, List[EventHandler]] = {}
        self._lock = asyncio.Lock()
        self._name = config.get("name", "unnamed_gateway")

    @property
    def name(self) -> str:
        """获取网关名称"""
        return self._name

    @property
    def is_connected(self) -> bool:
        """判断网关是否已连接"""
        return self.status == GatewayStatus.CONNECTED

    @property
    def is_disconnected(self) -> bool:
        """判断网关是否已断开"""
        return self.status in (GatewayStatus.DISCONNECTED, GatewayStatus.STOPPED)

    @abstractmethod
    async def connect(self) -> bool:
        """连接到交易所接口

        Returns:
            bool: 连接是否成功

        Raises:
            ConnectionError: 连接失败
            TimeoutError: 连接超时
            ConfigError: 配置错误
        """
        pass

    @abstractmethod
    async def disconnect(self) -> None:
        """断开与交易所接口的连接

        Raises:
            ConnectionError: 断开连接失败
        """
        pass

    @abstractmethod
    async def subscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """订阅合约行情

        Args:
            symbols: 合约代码列表

        Returns:
            Dict[str, bool]: 合约代码到订阅结果的映射

        Raises:
            SubscriptionError: 订阅失败
            ValueError: 参数错误
        """
        pass

    @abstractmethod
    async def unsubscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """取消订阅合约行情

        Args:
            symbols: 合约代码列表

        Returns:
            Dict[str, bool]: 合约代码到取消订阅结果的映射

        Raises:
            SubscriptionError: 取消订阅失败
            ValueError: 参数错误
        """
        pass

    def get_status(self) -> GatewayStatus:
        """获取网关当前状态

        Returns:
            GatewayStatus: 当前网关状态
        """
        return self.status

    def get_subscribed_symbols(self) -> List[str]:
        """获取已订阅的合约列表

        Returns:
            List[str]: 已订阅的合约代码列表
        """
        return list(self.subscribed_symbols)

    def get_subscribed_count(self) -> int:
        """获取已订阅合约数量

        Returns:
            int: 已订阅的合约数量
        """
        return len(self.subscribed_symbols)

    def is_subscribed(self, symbol: str) -> bool:
        """检查合约是否已订阅

        Args:
            symbol: 合约代码

        Returns:
            bool: 是否已订阅
        """
        return symbol in self.subscribed_symbols

    def on_event(self, event_type: str, handler: EventHandler) -> None:
        """注册事件处理器

        Args:
            event_type: 事件类型
            handler: 事件处理器函数（异步函数）

        Example:
            async def handle_tick(data):
                print(f"Received tick: {data}")

            gateway.on_event("tick_data", handle_tick)
        """
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        if handler not in self.event_handlers[event_type]:
            self.event_handlers[event_type].append(handler)
            logger.debug(f"Registered handler for event type: {event_type}")

    def off_event(self, event_type: str, handler: Optional[EventHandler] = None) -> bool:
        """取消注册事件处理器

        Args:
            event_type: 事件类型
            handler: 要移除的处理器，如果为None则移除该类型的所有处理器

        Returns:
            bool: 是否成功移除
        """
        if event_type not in self.event_handlers:
            return False

        if handler is None:
            del self.event_handlers[event_type]
            logger.debug(f"Removed all handlers for event type: {event_type}")
            return True

        if handler in self.event_handlers[event_type]:
            self.event_handlers[event_type].remove(handler)
            logger.debug(f"Removed handler for event type: {event_type}")
            return True

        return False

    async def emit_event(self, event_type: str, data: Any) -> None:
        """触发事件，并行执行所有处理器

        Args:
            event_type: 事件类型
            data: 事件数据
        """
        if event_type not in self.event_handlers:
            return

        handlers = self.event_handlers[event_type]
        if not handlers:
            return

        # 使用 gather 并行执行所有事件处理器，提高性能
        results = await asyncio.gather(
            *[handler(data) for handler in handlers],
            return_exceptions=True
        )

        # 记录处理器执行中的异常
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                logger.error(
                    f"Error in event handler for {event_type}: {result}",
                    exc_info=result
                )

    async def emit_event_sync(self, event_type: str, data: Any) -> None:
        """触发事件，顺序执行所有处理器

        适用于需要保证执行顺序的场景。

        Args:
            event_type: 事件类型
            data: 事件数据
        """
        if event_type not in self.event_handlers:
            return

        for handler in self.event_handlers[event_type]:
            try:
                await handler(data)
            except Exception as e:
                logger.error(f"Error in event handler for {event_type}: {e}")

    def clear_event_handlers(self, event_type: Optional[str] = None) -> None:
        """清除事件处理器

        Args:
            event_type: 要清除的事件类型，如果为None则清除所有
        """
        if event_type is None:
            self.event_handlers.clear()
            logger.debug("Cleared all event handlers")
        elif event_type in self.event_handlers:
            self.event_handlers[event_type].clear()
            logger.debug(f"Cleared handlers for event type: {event_type}")

    def __repr__(self) -> str:
        """返回网关的字符串表示"""
        return (f"{self.__class__.__name__}("
                f"name={self._name}, "
                f"status={self.status.value}, "
                f"subscribed={len(self.subscribed_symbols)})")


__all__ = [
    'MarketGateway',
    'GatewayStatus',
    'ConnectionInfo',
    'EventHandler'
]
