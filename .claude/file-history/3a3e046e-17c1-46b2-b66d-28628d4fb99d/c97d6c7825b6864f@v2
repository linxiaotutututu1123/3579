# -*- coding: utf-8 -*-
"""Risk Management Module

Provides trading risk control functionality including:
- Position risk monitoring
- Capital risk control
- Stop-loss management
- Risk metrics calculation
"""

from dataclasses import dataclass, field
from decimal import Decimal
from typing import Dict, List, Optional, Any
from enum import Enum
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class RiskLevel(Enum):
    """Risk level enumeration"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class RiskType(Enum):
    """Risk type enumeration"""
    POSITION = "position"
    DRAWDOWN = "drawdown"
    CONCENTRATION = "concentration"
    VOLATILITY = "volatility"
    LIQUIDITY = "liquidity"


@dataclass
class RiskMetrics:
    """Risk metrics data class"""
    max_drawdown: Decimal = Decimal("0")
    current_drawdown: Decimal = Decimal("0")
    daily_pnl: Decimal = Decimal("0")
    position_value: Decimal = Decimal("0")
    margin_ratio: Decimal = Decimal("0")
    risk_level: RiskLevel = RiskLevel.LOW
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "max_drawdown": float(self.max_drawdown),
            "current_drawdown": float(self.current_drawdown),
            "daily_pnl": float(self.daily_pnl),
            "position_value": float(self.position_value),
            "margin_ratio": float(self.margin_ratio),
            "risk_level": self.risk_level.value,
            "timestamp": self.timestamp.isoformat()
        }


@dataclass
class RiskAlert:
    """Risk alert data class"""
    alert_id: str
    risk_type: RiskType
    level: RiskLevel
    message: str
    symbol: Optional[str] = None
    threshold: Optional[Decimal] = None
    current_value: Optional[Decimal] = None
    timestamp: datetime = field(default_factory=datetime.now)
    acknowledged: bool = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "alert_id": self.alert_id,
            "risk_type": self.risk_type.value,
            "level": self.level.value,
            "message": self.message,
            "symbol": self.symbol,
            "threshold": float(self.threshold) if self.threshold else None,
            "current_value": float(self.current_value) if self.current_value else None,
            "timestamp": self.timestamp.isoformat(),
            "acknowledged": self.acknowledged
        }


class RiskManager:
    """Risk Manager class"""

    def __init__(
        self,
        max_position_value: Decimal = Decimal("1000000"),
        max_drawdown_pct: Decimal = Decimal("0.1"),
        max_daily_loss: Decimal = Decimal("50000"),
        max_single_loss: Decimal = Decimal("10000")
    ):
        self.max_position_value = max_position_value
        self.max_drawdown_pct = max_drawdown_pct
        self.max_daily_loss = max_daily_loss
        self.max_single_loss = max_single_loss
        self._alerts: List[RiskAlert] = []
        self._metrics = RiskMetrics()
        self._is_trading_allowed = True
        logger.info(f"RiskManager initialized with max_position={max_position_value}")

    def check_order_risk(
        self,
        symbol: str,
        direction: str,
        price: Decimal,
        volume: int,
        current_position: int = 0
    ) -> tuple:
        """Check order risk"""
        if not self._is_trading_allowed:
            return False, "Trading has been suspended by risk control"

        order_value = price * volume

        if order_value > self.max_single_loss * 10:
            return False, f"Order value {order_value} exceeds single limit"

        new_position_value = self._metrics.position_value + order_value
        if new_position_value > self.max_position_value:
            return False, f"Total position value {new_position_value} exceeds limit {self.max_position_value}"

        return True, None

    def update_metrics(
        self,
        position_value: Decimal,
        daily_pnl: Decimal,
        equity: Decimal,
        peak_equity: Decimal
    ) -> RiskMetrics:
        """Update risk metrics"""
        if peak_equity > 0:
            current_drawdown = (peak_equity - equity) / peak_equity
        else:
            current_drawdown = Decimal("0")

        max_drawdown = max(self._metrics.max_drawdown, current_drawdown)

        if current_drawdown >= self.max_drawdown_pct:
            risk_level = RiskLevel.CRITICAL
            self._is_trading_allowed = False
            self._add_alert(
                RiskType.DRAWDOWN,
                RiskLevel.CRITICAL,
                f"Drawdown {current_drawdown:.2%} exceeds threshold {self.max_drawdown_pct:.2%}"
            )
        elif current_drawdown >= self.max_drawdown_pct * Decimal("0.8"):
            risk_level = RiskLevel.HIGH
        elif current_drawdown >= self.max_drawdown_pct * Decimal("0.5"):
            risk_level = RiskLevel.MEDIUM
        else:
            risk_level = RiskLevel.LOW

        if daily_pnl < -self.max_daily_loss:
            self._is_trading_allowed = False
            self._add_alert(
                RiskType.DRAWDOWN,
                RiskLevel.CRITICAL,
                f"Daily loss {daily_pnl} exceeds threshold {self.max_daily_loss}"
            )

        self._metrics = RiskMetrics(
            max_drawdown=max_drawdown,
            current_drawdown=current_drawdown,
            daily_pnl=daily_pnl,
            position_value=position_value,
            margin_ratio=position_value / equity if equity > 0 else Decimal("0"),
            risk_level=risk_level
        )

        return self._metrics

    def _add_alert(
        self,
        risk_type: RiskType,
        level: RiskLevel,
        message: str,
        symbol: Optional[str] = None
    ) -> RiskAlert:
        """Add risk alert"""
        import uuid
        alert = RiskAlert(
            alert_id=str(uuid.uuid4())[:8],
            risk_type=risk_type,
            level=level,
            message=message,
            symbol=symbol
        )
        self._alerts.append(alert)
        logger.warning(f"Risk Alert: [{level.value}] {message}")
        return alert

    def get_metrics(self) -> RiskMetrics:
        """Get current risk metrics"""
        return self._metrics

    def get_alerts(self, unacknowledged_only: bool = False) -> List[RiskAlert]:
        """Get risk alerts"""
        if unacknowledged_only:
            return [a for a in self._alerts if not a.acknowledged]
        return self._alerts.copy()

    def acknowledge_alert(self, alert_id: str) -> bool:
        """Acknowledge risk alert"""
        for alert in self._alerts:
            if alert.alert_id == alert_id:
                alert.acknowledged = True
                return True
        return False

    def reset_daily(self) -> None:
        """Reset daily metrics"""
        self._metrics.daily_pnl = Decimal("0")
        self._is_trading_allowed = True
        logger.info("Daily risk metrics reset")

    def is_trading_allowed(self) -> bool:
        """Check if trading is allowed"""
        return self._is_trading_allowed

    def resume_trading(self) -> None:
        """Resume trading"""
        self._is_trading_allowed = True
        logger.info("Trading resumed by manual confirmation")


__all__ = [
    'RiskLevel',
    'RiskType',
    'RiskMetrics',
    'RiskAlert',
    'RiskManager'
]
