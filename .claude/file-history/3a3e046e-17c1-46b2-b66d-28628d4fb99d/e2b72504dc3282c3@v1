"""CTP行情网关单元测试

使用pytest和unittest.mock模拟pyctp库的回调函数，
验证CtpMarketGateway类的各项功能。
"""

import asyncio
import pytest
from decimal import Decimal
from typing import Dict, Any
from unittest.mock import AsyncMock, Mock, patch

from src.models.tick_data import TickData
from src.market_gateway.base import GatewayStatus
from src.market_gateway.events import EventType
from src.market_gateway.exceptions import (
    ConnectionError,
    SubscriptionError,
    ConfigError,
    DataValidationError
)
from src.market_gateway.ctp_gateway import CtpMarketGateway


class TestCtpMarketGateway:
    """CtpMarketGateway测试类"""
    
    @pytest.fixture
    def mock_config(self):
        """模拟配置对象"""
        # 这里将在实现后替换为真实配置
        ctp_config = {
            "front_addr": "tcp://180.168.146.187:10131",
            "broker_id": "9999",
            "user_id": "test_user",
            "password": "test_password",
            "connect_timeout": 10,
            "heartbeat_interval": 30
        }
        
        gateway_config = {
            "name": "TestGateway",
            "enabled": True,
            "ctp": ctp_config,
            "max_reconnect_attempts": 3,
            "max_backoff_seconds": 60,
            "initial_backoff_seconds": 1,
            # 其他配置参数...
        }
        
        return gateway_config
    
    @pytest.fixture
    def sample_ctp_tick_data(self):
        """模拟CTP格式的Tick数据"""
        return {
            "InstrumentID": "rb2401",
            "ExchangeID": "SHFE",
            "LastPrice": 3000.0,
            "Volume": 1000,
            "Turnover": 3000000.0,
            "OpenInterest": 5000,
            "BidPrice1": 2999.0,
            "AskPrice1": 3001.0,
            "BidVolume1": 10,
            "AskVolume1": 15,
            "UpperLimitPrice": 3200.0,
            "LowerLimitPrice": 2800.0,
            "UpdateTime": "15:00:00",
            "UpdateMillisec": 500,
            "TradingDay": "20231201",
            "ActionDay": "20231201"
        }
    
    @pytest.fixture
    def mock_gateway(self, mock_config):
        """模拟网关实例"""
        with patch('src.market_gateway.ctp_gateway.CThostFtdcMdApi') as mock_api:
            gateway = CtpMarketGateway(mock_config)
            gateway.api = mock_api
            yield gateway
    
    @pytest.mark.asyncio
    async def test_normal_tick_data_conversion(self, mock_gateway, sample_ctp_tick_data):
        """测试正常行情推送（验证TickData转换）
        
        Arrange: 准备有效的CTP Tick数据和模拟网关
        Act: 调用on_tick方法处理数据
        Assert: 验证TickData对象创建成功且字段正确
        """
        # Arrange
        gateway = mock_gateway
        ctp_data = sample_ctp_tick_data
        
        # Act
        result = await gateway.on_tick(ctp_data)
        
        # Assert
        assert isinstance(result, TickData)
        assert result.symbol == "rb2401"
        assert result.exchange == "SHFE"
        assert result.last_price == Decimal("3000.0")
        assert result.volume == 1000
        assert result.bid_price_1 == Decimal("2999.0")
        assert result.ask_price_1 == Decimal("3001.0")
        assert result.is_valid == True
    
    @pytest.mark.asyncio
    async def test_reconnect_exponential_backoff(self, mock_gateway):
        """测试断线重连（模拟断线3次，验证指数退避间隔）
        
        Arrange: 模拟连接断开并准备重连尝试
        Act: 触发重连机制
        Assert: 验证重连尝试次数和时间间隔符合指数退避策略
        """
        # Arrange
        gateway = mock_gateway
        gateway.status = GatewayStatus.DISCONNECTED
        mock_connect = AsyncMock(side_effect=[False, False, True])
        gateway.connect = mock_connect
        
        # Act
        reconnect_result = await gateway.reconnect()
        
        # Assert
        assert reconnect_result == True
        assert mock_connect.call_count == 3
        # 验证指数退避时间间隔 (1s, 2s, 4s)
        # 注意：实际测试中可能需要mock sleep函数来避免等待
    
    @pytest.mark.asyncio
    async def test_invalid_data_filtering(self, mock_gateway):
        """测试异常数据过滤（price=-1, volume=0）
        
        Arrange: 准备无效的CTP Tick数据（价格为-1或成交量为0）
        Act: 调用on_tick方法处理数据
        Assert: 验证无效数据被过滤，不产生TickData对象
        """
        # Arrange
        gateway = mock_gateway
        invalid_tick_data = {
            "InstrumentID": "rb2401",
            "ExchangeID": "SHFE",
            "LastPrice": -1,  # 无效价格
            "Volume": 1000,
            "Turnover": 3000000.0,
            "OpenInterest": 5000,
            "UpdateTime": "15:00:00",
            "UpdateMillisec": 500,
            "TradingDay": "20231201",
            "ActionDay": "20231201"
        }
        
        # Act
        result = await gateway.on_tick(invalid_tick_data)
        
        # Assert
        assert result is None  # 无效数据应该被过滤
    
    @pytest.mark.asyncio
    async def test_duplicate_subscription_idempotency(self, mock_gateway):
        """测试重复订阅幂等性
        
        Arrange: 准备模拟网关和合约列表
        Act: 多次订阅同一合约
        Assert: 验证订阅结果一致，不会重复订阅
        """
        # Arrange
        gateway = mock_gateway
        symbols = ["rb2401", "cu2401"]
        
        # Act
        result1 = await gateway.subscribe(symbols)
        result2 = await gateway.subscribe(symbols)  # 重复订阅
        
        # Assert
        assert result1 == result2
        # 验证订阅列表中不重复
        assert len(gateway.subscribed_symbols) == len(symbols)
        assert all(symbol in gateway.subscribed_symbols for symbol in symbols)
    
    @pytest.mark.asyncio
    async def test_config_error_handling(self, mock_config):
        """测试配置错误（错误服务器地址）
        
        Arrange: 准备错误的配置（无效服务器地址）
        Act: 尝试初始化网关
        Assert: 验证初始化失败并抛出适当异常
        """
        # Arrange
        invalid_config = mock_config.copy()
        invalid_config["ctp"]["front_addr"] = "invalid_address"
        
        # Act & Assert
        with pytest.raises(ConfigError):
            CtpMarketGateway(invalid_config)
    
    @pytest.mark.benchmark
    def test_tick_processing_performance(self, mock_gateway, sample_ctp_tick_data, benchmark):
        """测试Tick数据处理性能（目标<1ms/次）
        
        Arrange: 准备有效的CTP Tick数据和模拟网关
        Act: 使用benchmark测试on_tick方法性能
        Assert: 验证处理时间小于1ms
        """
        # Arrange
        gateway = mock_gateway
        ctp_data = sample_ctp_tick_data
        
        # Act & Assert
        async def async_on_tick():
            return await gateway.on_tick(ctp_data)
        
        result = benchmark(lambda: asyncio.run(async_on_tick()))
        assert isinstance(result, TickData)

__all__ = ['TestCtpMarketGateway']