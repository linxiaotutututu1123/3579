"""CTP行情网关实现

实现基于CTP接口的行情网关，负责连接CTP服务器、订阅行情、
处理数据转换和发布等功能。
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any, Callable
from decimal import Decimal
from datetime import datetime

from .base import MarketGateway, GatewayStatus
from .events import EventType, TickDataEvent
from .exceptions import (
    ConnectionError,
    SubscriptionError,
    ConfigError,
    DataValidationError
)
from ..models.tick_data import TickData
from ..config.gateway_config import GatewayConfig

# 假设这是CTP接口的Python封装
# from ctp_api import CThostFtdcMdApi

logger = logging.getLogger(__name__)

# 常量定义
# CTP API错误代码
CTP_ERROR_NONE = 0
CTP_ERROR_NETWORK = 1
CTP_ERROR_AUTH = 2
# 最大重连延迟时间（秒）
MAX_RECONNECT_DELAY_SECONDS = 300
# 默认连接超时时间（秒）
DEFAULT_CONNECT_TIMEOUT = 10
# 默认心跳间隔（秒）
DEFAULT_HEARTBEAT_INTERVAL = 30
# 数据处理队列最大大小，防止内存溢出
MAX_DATA_QUEUE_SIZE = 10000
# CTP无效价格标识（DBL_MAX）
CTP_INVALID_PRICE = 1.7976931348623157e+308


class CtpMarketGateway(MarketGateway):
    """CTP行情网关实现"""
    
    # 注意：父类MarketGateway没有定义__slots__，所以这里的__slots__只对子类新增属性有效
    # 父类属性（config, status, subscribed_symbols, event_handlers, _lock）仍存储在__dict__中
    __slots__ = (
        'gateway_config', 'api', 'request_id', 'connected', 'logged_in',
        'subscription_lock', 'reconnect_attempts',
        'should_reconnect', '_data_queue', '_heartbeat_task',
        '_stats', '_last_tick_time'
    )
    
    def __init__(self, config: Dict[str, Any]):
        """初始化CTP行情网关
        
        Args:
            config: 网关配置字典
            
        Raises:
            ConfigError: 配置无效时抛出
        """
        # 为什么先调用父类初始化：确保基础属性和事件队列先创建
        super().__init__(config)
        try:
            # 为什么使用GatewayConfig：提供配置验证和默认值
            self.gateway_config = GatewayConfig(**config)
        except Exception as e:
            raise ConfigError(f"Invalid gateway configuration: {str(e)}")
        
        # CTP API实例 - 为什么延迟初始化：避免在配置验证失败时创建资源
        self.api = None  # CThostFtdcMdApi.CreateFtdcMdApi()
        
        # 连接状态管理
        self.request_id = 0
        self.connected = False
        self.logged_in = False

        # 订阅管理锁 - 为什么使用锁：防止并发订阅导致状态不一致
        # 注意：subscribed_symbols 已在父类中初始化为 set()
        self.subscription_lock = asyncio.Lock()
        
        # 重连管理
        self.reconnect_attempts = 0
        self.should_reconnect = True
        
        # 为什么创建数据处理队列：防止高并发时内存溢出
        self._data_queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue(maxsize=MAX_DATA_QUEUE_SIZE)

        # 心跳任务
        self._heartbeat_task: Optional[asyncio.Task[None]] = None

        # 统计指标
        self._stats: Dict[str, int] = {
            'ticks_received': 0,
            'ticks_processed': 0,
            'ticks_filtered': 0,
            'errors': 0,
            'reconnects': 0
        }

        # 最后一次接收Tick的时间
        self._last_tick_time: Optional[datetime] = None

        logger.info(f"Initialized CtpMarketGateway: {self.gateway_config.name}")

    async def _wait_for_condition(
        self,
        condition: Callable[[], bool],
        timeout: float = 30.0,
        interval: float = 0.1
    ) -> bool:
        """等待条件满足

        Args:
            condition: 条件检查函数，返回True表示条件满足
            timeout: 超时时间（秒）
            interval: 检查间隔（秒）

        Returns:
            bool: 条件是否在超时前满足
        """
        start_time = asyncio.get_event_loop().time()
        while asyncio.get_event_loop().time() - start_time < timeout:
            if condition():
                return True
            await asyncio.sleep(interval)
        return False

    async def _heartbeat_loop(self) -> None:
        """心跳循环，定期检查连接状态"""
        heartbeat_interval = (
            self.gateway_config.ctp.heartbeat_interval
            if self.gateway_config.ctp.heartbeat_interval
            else DEFAULT_HEARTBEAT_INTERVAL
        )
        while self.connected and self.should_reconnect:
            try:
                await asyncio.sleep(heartbeat_interval)

                # 检查是否长时间未收到数据
                if self._last_tick_time:
                    idle_time = (datetime.now() - self._last_tick_time).total_seconds()
                    if idle_time > heartbeat_interval * 2:
                        logger.warning(f"No tick data received for {idle_time:.1f} seconds")

                # 这里可以添加实际的心跳检测逻辑
                # 例如发送心跳包或检查API状态
                logger.debug("Heartbeat check passed")

            except asyncio.CancelledError:
                logger.info("Heartbeat loop cancelled")
                break
            except Exception as e:
                logger.error(f"Heartbeat error: {str(e)}")
                self._stats['errors'] += 1

    async def connect(self) -> bool:
        """连接到CTP行情服务器
        
        Returns:
            bool: 连接是否成功
            
        Raises:
            ConnectionError: 连接失败
            TimeoutError: 连接超时
            ConfigError: 配置错误
        """
        # 为什么检查enabled：允许禁用网关进行测试或维护
        if not self.gateway_config.enabled:
            logger.warning("Gateway is disabled, skipping connection")
            return False
            
        try:
            ctp_config = self.gateway_config.ctp

            # 更新状态
            self.status = GatewayStatus.CONNECTING
            logger.info(f"Connecting to CTP server: {ctp_config.front_addr}")

            # 为什么设置超时：防止连接无限等待
            connect_timeout = ctp_config.connect_timeout or DEFAULT_CONNECT_TIMEOUT

            # RISK: CTP API调用可能阻塞，需要超时控制
            # 为什么使用try-except：处理CTP API可能的异常
            try:
                # 初始化API
                # self.api.RegisterSpi(self)
                # self.api.RegisterFront(ctp_config.front_addr)
                # self.api.Init()

                # 等待连接建立
                # await asyncio.wait_for(
                #     self._wait_for_condition(lambda: self.connected),
                #     timeout=connect_timeout
                # )

                # 登录认证
                # success = await self._login()
                # if not success:
                #     raise AuthenticationError("Failed to authenticate with CTP server")

                # 临时模拟连接成功
                self.connected = True
                self.logged_in = True

            except asyncio.TimeoutError:
                # RISK: 连接超时可能导致资源泄漏
                logger.error(f"Connection timeout after {connect_timeout} seconds")
                raise TimeoutError(f"Connection timeout after {connect_timeout} seconds")
                
            self.status = GatewayStatus.CONNECTED
            self.reconnect_attempts = 0

            # 启动心跳任务
            if self._heartbeat_task is None or self._heartbeat_task.done():
                self._heartbeat_task = asyncio.create_task(self._heartbeat_loop())

            logger.info("Successfully connected to CTP server")
            return True
            
        except Exception as e:
            self.status = GatewayStatus.ERROR
            logger.error(f"Failed to connect to CTP server: {str(e)}")
            raise ConnectionError(f"Connection failed: {str(e)}")

    async def _login(self) -> bool:
        """登录到CTP服务器
        
        Returns:
            bool: 登录是否成功
        """
        # 这里应该是实际的登录逻辑
        # req = {
        #     "BrokerID": self.gateway_config.ctp.broker_id,
        #     "UserID": self.gateway_config.ctp.user_id,
        #     "Password": self.gateway_config.ctp.password,
        #     "AppID": self.gateway_config.ctp.app_id or "",
        #     "AuthCode": self.gateway_config.ctp.auth_code or ""
        # }
        # 
        # self.request_id += 1
        # return self.api.ReqUserLogin(req, self.request_id)
        return True  # 临时返回True

    async def subscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """订阅合约行情

        Args:
            symbols: 合约代码列表

        Returns:
            Dict[str, bool]: 合约代码到订阅结果的映射

        Raises:
            SubscriptionError: 订阅失败
        """
        # 为什么检查空列表：避免无意义的API调用
        if not symbols:
            logger.warning("No symbols provided for subscription")
            return {}

        # 为什么使用锁：防止并发订阅导致状态不一致
        async with self.subscription_lock:
            try:
                result: Dict[str, bool] = {}

                # 过滤已订阅的合约 - 为什么先过滤：避免重复订阅
                new_symbols = [s for s in symbols if s not in self.subscribed_symbols]

                # 已订阅的标记为成功
                for s in symbols:
                    if s in self.subscribed_symbols:
                        result[s] = True

                if not new_symbols:
                    logger.info("All symbols already subscribed")
                    return result

                # RISK: 订阅过多合约可能导致服务器拒绝
                # 为什么检查订阅限制：避免超过服务器限制
                if len(self.subscribed_symbols) + len(new_symbols) > self.gateway_config.max_subscriptions:
                    raise SubscriptionError(
                        f"Subscription limit exceeded: {self.gateway_config.max_subscriptions}"
                    )

                # 执行订阅
                # api_result = self.api.SubscribeMarketData(new_symbols)
                # if not api_result:
                #     raise SubscriptionError("Failed to subscribe to market data")

                # 更新订阅列表 - 为什么先更新再触发事件：确保事件处理时状态一致
                for s in new_symbols:
                    self.subscribed_symbols.add(s)
                    result[s] = True

                logger.info(f"Subscribed to symbols: {new_symbols}")

                # 触发订阅事件
                await self.emit_event(EventType.SUBSCRIBED.value, {"symbols": new_symbols})

                return result

            except Exception as e:
                # RISK: 订阅失败可能导致状态不一致
                logger.error(f"Failed to subscribe to symbols {symbols}: {str(e)}")
                raise SubscriptionError(f"Subscription failed: {str(e)}")

    async def unsubscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """取消订阅合约行情

        Args:
            symbols: 合约代码列表

        Returns:
            Dict[str, bool]: 合约代码到取消订阅结果的映射

        Raises:
            SubscriptionError: 取消订阅失败
        """
        # 为什么检查空列表：避免无意义的API调用
        if not symbols:
            logger.warning("No symbols provided for unsubscription")
            return {}

        # 为什么使用锁：防止并发操作导致状态不一致
        async with self.subscription_lock:
            try:
                result: Dict[str, bool] = {}

                # 过滤未订阅的合约 - 为什么先过滤：避免无效的API调用
                subscribed_to_remove = [s for s in symbols if s in self.subscribed_symbols]

                # 未订阅的标记为成功（无需取消）
                for s in symbols:
                    if s not in self.subscribed_symbols:
                        result[s] = True

                if not subscribed_to_remove:
                    logger.info("No symbols to unsubscribe")
                    return result

                # 执行取消订阅
                # api_result = self.api.UnSubscribeMarketData(subscribed_to_remove)
                # if not api_result:
                #     raise SubscriptionError("Failed to unsubscribe from market data")

                # RISK: API成功但本地状态更新失败可能导致状态不一致
                # 为什么先更新状态再触发事件：确保事件处理时状态一致
                for s in subscribed_to_remove:
                    self.subscribed_symbols.discard(s)
                    result[s] = True

                logger.info(f"Unsubscribed from symbols: {subscribed_to_remove}")

                # 触发取消订阅事件
                await self.emit_event(EventType.UNSUBSCRIBED.value, {"symbols": subscribed_to_remove})

                return result

            except Exception as e:
                # RISK: 取消订阅失败可能导致状态不一致
                logger.error(f"Failed to unsubscribe from symbols {symbols}: {str(e)}")
                raise SubscriptionError(f"Unsubscription failed: {str(e)}")

    async def on_tick(self, ctp_data: Dict[str, Any]) -> Optional[TickData]:
        """处理CTP格式的Tick数据

        Args:
            ctp_data: CTP格式的行情数据

        Returns:
            TickData: 标准化的Tick数据对象，如果数据无效则返回None
        """
        self._stats['ticks_received'] += 1

        try:
            # 为什么先清洗数据：避免无效数据占用处理资源
            # 数据清洗和验证
            cleaned_data = self._clean_tick_data(ctp_data)
            if not cleaned_data:
                self._stats['ticks_filtered'] += 1
                logger.debug(f"Invalid tick data filtered: {ctp_data}")
                return None

            # 转换为标准TickData对象
            tick_data = self._convert_to_tick_data(cleaned_data)

            # 数据验证
            if not tick_data.is_valid:
                self._stats['ticks_filtered'] += 1
                logger.warning(f"Invalid tick data: {tick_data}")
                return None

            # RISK: 高频数据可能导致事件队列溢出
            # 为什么检查队列大小：防止内存溢出
            if self._data_queue.qsize() >= MAX_DATA_QUEUE_SIZE * 0.8:
                logger.warning("Data queue approaching capacity limit, dropping oldest items")
                try:
                    self._data_queue.get_nowait()
                except asyncio.QueueEmpty:
                    pass

            # 更新最后接收时间
            self._last_tick_time = datetime.now()

            # 发布事件
            event = TickDataEvent(
                symbol=tick_data.symbol,
                tick_data=tick_data.model_dump(),
                timestamp=datetime.now(),
                source=self.gateway_config.name,
                data=tick_data
            )
            await self.emit_event(EventType.TICK_DATA.value, event)

            self._stats['ticks_processed'] += 1
            return tick_data

        except DataValidationError as e:
            # 为什么捕获特定异常：区分数据错误和系统错误
            self._stats['errors'] += 1
            logger.warning(f"Data validation error: {str(e)}")
            return None
        except Exception as e:
            # RISK: 未捕获异常可能导致数据处理中断
            self._stats['errors'] += 1
            logger.error(f"Error processing tick data: {str(e)}")
            return None

    def _clean_tick_data(self, ctp_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """清洗CTP格式的Tick数据

        Args:
            ctp_data: 原始CTP数据

        Returns:
            Dict: 清洗后的数据，如果数据无效则返回None
        """
        try:
            # 为什么检查基本字段：确保数据完整性
            # 检查基本字段
            required_fields = ["InstrumentID", "ExchangeID", "LastPrice", "Volume"]
            for field in required_fields:
                if field not in ctp_data or ctp_data[field] is None:
                    logger.debug(f"Missing required field: {field}")
                    return None

            # 价格验证 - 为什么检查价格：防止异常价格影响交易决策
            last_price = float(ctp_data.get("LastPrice", 0))
            # CTP 使用 DBL_MAX 表示无效价格
            if last_price <= 0 or last_price >= CTP_INVALID_PRICE:
                logger.debug(f"Invalid last price: {last_price}")
                return None

            # 成交量验证 - 为什么检查成交量：防止异常成交量影响统计
            volume = int(ctp_data.get("Volume", 0))
            if volume < 0:
                logger.debug(f"Invalid volume: {volume}")
                return None

            # 时间戳处理 - 为什么检查时间戳：确保数据时效性
            update_time = ctp_data.get("UpdateTime", "")
            trading_day = ctp_data.get("TradingDay", "")

            if not update_time or not trading_day:
                logger.debug("Missing timestamp information")
                return None

            # 解析CTP时间戳
            tick_datetime = self._parse_ctp_datetime(trading_day, update_time, ctp_data.get("UpdateMillisec", 0))
            if tick_datetime is None:
                logger.debug("Failed to parse CTP datetime")
                return None

            # 数据正常，返回清洗后的数据
            cleaned = ctp_data.copy()
            cleaned["datetime"] = tick_datetime
            cleaned["local_datetime"] = datetime.now()

            return cleaned

        except Exception as e:
            # RISK: 数据清洗异常可能导致大量数据丢失
            logger.error(f"Error cleaning tick data: {str(e)}")
            return None

    def _parse_ctp_datetime(
        self,
        trading_day: str,
        update_time: str,
        update_millisec: int = 0
    ) -> Optional[datetime]:
        """解析CTP时间戳

        Args:
            trading_day: 交易日，格式 YYYYMMDD
            update_time: 更新时间，格式 HH:MM:SS
            update_millisec: 毫秒数

        Returns:
            datetime: 解析后的时间戳，解析失败返回None
        """
        try:
            # 构造完整时间戳
            datetime_str = f"{trading_day} {update_time}"
            dt = datetime.strptime(datetime_str, "%Y%m%d %H:%M:%S")

            # 添加毫秒
            if update_millisec > 0:
                dt = dt.replace(microsecond=update_millisec * 1000)

            return dt
        except ValueError as e:
            logger.debug(f"Failed to parse CTP datetime: {e}")
            return None

    def _convert_to_tick_data(self, ctp_data: Dict[str, Any]) -> TickData:
        """将CTP数据转换为标准TickData对象

        Args:
            ctp_data: 清洗后的CTP数据

        Returns:
            TickData: 标准化的Tick数据对象
        """
        # 处理买卖盘价格（CTP使用DBL_MAX表示无效）
        bid_price_1 = ctp_data.get("BidPrice1", 0)
        ask_price_1 = ctp_data.get("AskPrice1", 0)

        # 将无效价格转换为0
        if bid_price_1 >= CTP_INVALID_PRICE:
            bid_price_1 = 0
        if ask_price_1 >= CTP_INVALID_PRICE:
            ask_price_1 = 0

        # 转换CTP字段名到标准字段名
        standard_data = {
            "symbol": ctp_data["InstrumentID"],
            "exchange": ctp_data["ExchangeID"],
            "datetime": ctp_data.get("datetime", datetime.now()),
            "local_datetime": ctp_data.get("local_datetime", datetime.now()),
            "last_price": Decimal(str(ctp_data["LastPrice"])),
            "volume": int(ctp_data.get("Volume", 0)),
            "turnover": Decimal(str(ctp_data.get("Turnover", 0))),
            "open_interest": int(ctp_data.get("OpenInterest", 0)),
            "bid_price_1": Decimal(str(bid_price_1)),
            "ask_price_1": Decimal(str(ask_price_1)),
            "bid_volume_1": int(ctp_data.get("BidVolume1", 0)),
            "ask_volume_1": int(ctp_data.get("AskVolume1", 0)),
        }

        # 使用TickData的from_raw_data方法进行转换
        # 这个方法会处理数据验证和类型转换
        return TickData.from_raw_data(standard_data, source=self.gateway_config.name)

    async def reconnect(self) -> bool:
        """执行重连操作，使用指数退避策略

        Returns:
            bool: 重连是否成功
        """
        # 为什么检查should_reconnect：允许手动禁用重连
        if not self.should_reconnect:
            logger.info("Reconnection disabled, skipping")
            return False

        # 为什么使用配置中的值：允许不同环境使用不同策略
        backoff = self.gateway_config.initial_backoff_seconds
        max_attempts = self.gateway_config.max_reconnect_attempts
        # max_attempts=0 表示无限重连
        unlimited = (max_attempts == 0)

        # RISK: 无限重连可能导致资源耗尽
        while unlimited or self.reconnect_attempts < max_attempts:
            self.status = GatewayStatus.RECONNECTING
            self.reconnect_attempts += 1
            self._stats['reconnects'] += 1
            if unlimited:
                logger.info(f"Reconnection attempt {self.reconnect_attempts} (unlimited)")
            else:
                logger.info(f"Reconnection attempt {self.reconnect_attempts}/{max_attempts}")

            # 为什么使用try-except：捕获连接异常并继续重试
            try:
                # 尝试连接
                if await self.connect():
                    logger.info("Reconnection successful")
                    # 为什么重新订阅：恢复断开前的订阅状态
                    # RISK: 重连后服务器端订阅状态已清空，需要重新订阅
                    if self.subscribed_symbols:
                        # 保存需要重新订阅的合约列表
                        symbols_to_resubscribe = list(self.subscribed_symbols)
                        # 清空本地订阅状态，避免subscribe()跳过已订阅的合约
                        self.subscribed_symbols.clear()
                        await self.subscribe(symbols_to_resubscribe)
                    return True
            except Exception as e:
                logger.warning(f"Reconnection attempt {self.reconnect_attempts} failed: {str(e)}")

            # 检查是否达到最大重连次数
            if not unlimited and self.reconnect_attempts >= max_attempts:
                logger.error("Max reconnection attempts reached")
                self.status = GatewayStatus.ERROR
                break

            # RISK: 长时间等待可能阻塞其他操作
            # 为什么记录等待日志：便于调试和监控
            logger.info(f"Waiting {backoff} seconds before next attempt")
            await asyncio.sleep(backoff)

            # 为什么使用指数退避：避免频繁重连加重服务器负担
            backoff = min(backoff * 2, min(self.gateway_config.max_backoff_seconds, MAX_RECONNECT_DELAY_SECONDS))
        
        return False

    async def disconnect(self) -> None:
        """断开与CTP服务器的连接

        Raises:
            ConnectionError: 断开连接失败
        """
        try:
            self.should_reconnect = False

            # 取消心跳任务
            if self._heartbeat_task and not self._heartbeat_task.done():
                self._heartbeat_task.cancel()
                try:
                    await self._heartbeat_task
                except asyncio.CancelledError:
                    pass
                self._heartbeat_task = None

            # 清空数据队列
            while not self._data_queue.empty():
                try:
                    self._data_queue.get_nowait()
                except asyncio.QueueEmpty:
                    break

            if self.api:
                # self.api.Release()
                self.api = None

            self.status = GatewayStatus.DISCONNECTED
            self.connected = False
            self.logged_in = False
            logger.info("Disconnected from CTP server")

        except Exception as e:
            logger.error(f"Error disconnecting from CTP server: {str(e)}")
            raise ConnectionError(f"Disconnect failed: {str(e)}")

    def is_healthy(self) -> bool:
        """检查网关是否健康

        Returns:
            bool: 网关是否处于健康状态
        """
        # 基本连接状态检查
        if self.status != GatewayStatus.CONNECTED:
            return False

        if not self.connected or not self.logged_in:
            return False

        # 检查最近是否有数据（如果有订阅的话）
        if self.subscribed_symbols and self._last_tick_time:
            idle_seconds = (datetime.now() - self._last_tick_time).total_seconds()
            # 超过5分钟没有数据认为不健康
            if idle_seconds > 300:
                return False

        return True

    def get_stats(self) -> Dict[str, Any]:
        """获取网关统计信息

        Returns:
            Dict[str, Any]: 统计信息字典
        """
        return {
            **self._stats,
            'status': self.status.value,
            'connected': self.connected,
            'logged_in': self.logged_in,
            'subscribed_count': len(self.subscribed_symbols),
            'queue_size': self._data_queue.qsize(),
            'last_tick_time': self._last_tick_time.isoformat() if self._last_tick_time else None,
            'is_healthy': self.is_healthy()
        }

    def reset_stats(self) -> None:
        """重置统计信息"""
        self._stats = {
            'ticks_received': 0,
            'ticks_processed': 0,
            'ticks_filtered': 0,
            'errors': 0,
            'reconnects': 0
        }
        logger.info("Gateway statistics reset")

    def __repr__(self) -> str:
        """返回网关的字符串表示"""
        return (f"CtpMarketGateway(name={self.gateway_config.name}, "
                f"status={self.status.value}, "
                f"subscribed_symbols={len(self.subscribed_symbols)})")

    # CTP API回调方法（实际使用时需要实现）
    def OnFrontConnected(self) -> None:
        """CTP前置连接成功回调"""
        logger.info("CTP front connected")
        self.connected = True

    def OnFrontDisconnected(self, nReason: int) -> None:
        """CTP前置断开连接回调
        
        Args:
            nReason: 断开原因代码
        """
        logger.warning(f"CTP front disconnected: {nReason}")
        self.connected = False
        self.logged_in = False
        self.status = GatewayStatus.DISCONNECTED
        
        # 如果启用自动重连，则触发重连
        if self.should_reconnect:
            asyncio.create_task(self.reconnect())

    def OnRspUserLogin(self, _pRspUserLogin: Any, pRspInfo: Any, _nRequestID: int, _bIsLast: bool) -> None:
        """CTP登录响应回调

        Args:
            _pRspUserLogin: 登录响应结构（未使用）
            pRspInfo: 响应信息结构
            _nRequestID: 请求ID（未使用）
            _bIsLast: 是否为最后一个响应（未使用）
        """
        if pRspInfo and pRspInfo.ErrorID != 0:
            logger.error(f"CTP login failed: {pRspInfo.ErrorMsg}")
            self.status = GatewayStatus.ERROR
            return
            
        logger.info("CTP login successful")
        self.logged_in = True
        self.status = GatewayStatus.CONNECTED

    def OnRspSubMarketData(self, pSpecificInstrument: Any, pRspInfo: Any, _nRequestID: int, _bIsLast: bool) -> None:
        """CTP订阅行情响应回调

        Args:
            pSpecificInstrument: 合约信息结构
            pRspInfo: 响应信息结构
            _nRequestID: 请求ID（未使用）
            _bIsLast: 是否为最后一个响应（未使用）
        """
        if pRspInfo and pRspInfo.ErrorID != 0:
            logger.error(f"CTP subscribe failed: {pRspInfo.ErrorMsg}")
            return
            
        symbol = pSpecificInstrument.InstrumentID if pSpecificInstrument else "unknown"
        logger.info(f"CTP subscribe successful: {symbol}")

    def OnRspUnSubMarketData(self, pSpecificInstrument: Any, pRspInfo: Any, _nRequestID: int, _bIsLast: bool) -> None:
        """CTP取消订阅行情响应回调

        Args:
            pSpecificInstrument: 合约信息结构
            pRspInfo: 响应信息结构
            _nRequestID: 请求ID（未使用）
            _bIsLast: 是否为最后一个响应（未使用）
        """
        if pRspInfo and pRspInfo.ErrorID != 0:
            logger.error(f"CTP unsubscribe failed: {pRspInfo.ErrorMsg}")
            return
            
        symbol = pSpecificInstrument.InstrumentID if pSpecificInstrument else "unknown"
        logger.info(f"CTP unsubscribe successful: {symbol}")

    def OnRtnDepthMarketData(self, pDepthMarketData: Any) -> None:
        """CTP行情数据回调
        
        Args:
            pDepthMarketData: 深度行情数据结构
        """
        try:
            # 为什么使用try-except：防止CTP回调异常导致连接中断
            # 将CTP结构转换为字典
            ctp_data = {}
            if pDepthMarketData:
                # 这里应该根据实际的CTP API结构提取数据
                # 示例代码，实际使用时需要根据CTP API文档调整
                ctp_data = {
                    "InstrumentID": getattr(pDepthMarketData, "InstrumentID", ""),
                    "ExchangeID": getattr(pDepthMarketData, "ExchangeID", ""),
                    "LastPrice": getattr(pDepthMarketData, "LastPrice", 0),
                    "Volume": getattr(pDepthMarketData, "Volume", 0),
                    "Turnover": getattr(pDepthMarketData, "Turnover", 0),
                    "OpenInterest": getattr(pDepthMarketData, "OpenInterest", 0),
                    "BidPrice1": getattr(pDepthMarketData, "BidPrice1", 0),
                    "AskPrice1": getattr(pDepthMarketData, "AskPrice1", 0),
                    "BidVolume1": getattr(pDepthMarketData, "BidVolume1", 0),
                    "AskVolume1": getattr(pDepthMarketData, "AskVolume1", 0),
                    "UpdateTime": getattr(pDepthMarketData, "UpdateTime", ""),
                    "TradingDay": getattr(pDepthMarketData, "TradingDay", ""),
                    "UpdateMillisec": getattr(pDepthMarketData, "UpdateMillisec", 0),
                }
            
            # RISK: 同步回调中创建异步任务可能导致任务堆积
            # 为什么使用create_task：避免阻塞CTP回调线程
            asyncio.create_task(self.on_tick(ctp_data))
            
        except Exception as e:
            # RISK: 回调中的异常可能导致CTP连接中断
            # 为什么记录错误但不抛出：避免影响CTP API正常运行
            logger.error(f"Error processing CTP market data: {str(e)}")


__all__ = ['CtpMarketGateway']