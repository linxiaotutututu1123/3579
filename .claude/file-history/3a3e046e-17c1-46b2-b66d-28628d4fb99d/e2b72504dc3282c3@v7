"""CTP行情网关单元测试

使用pytest和unittest.mock模拟pyctp库的回调函数，
验证CtpMarketGateway类的各项功能。

测试原则：
1. 每个测试遵循Arrange-Act-Assert结构
2. 使用mock隔离外部依赖
3. 测试覆盖率目标>90%
4. 性能测试使用pytest-benchmark
"""

import asyncio
import copy
import pytest
from decimal import Decimal
from unittest.mock import AsyncMock, Mock, patch

from src.models.tick_data import TickData
from src.market_gateway.base import GatewayStatus
from src.market_gateway.exceptions import (
    ConnectionError,
    ConfigError
)
from src.market_gateway.ctp_gateway import CtpMarketGateway

# 测试常量定义 - 为什么定义常量：避免魔法数字，提高测试可维护性
TEST_SYMBOL = "rb2401"  # 测试用合约代码
TEST_EXCHANGE = "SHFE"  # 测试用交易所
TEST_PRICE = Decimal("3000.0")  # 测试用价格
TEST_VOLUME = 1000  # 测试用成交量
PERFORMANCE_TARGET_MS = 1  # 性能目标（毫秒）


class TestCtpMarketGateway:
    """CtpMarketGateway测试类
    
    测试覆盖范围：
    1. 正常行情数据处理
    2. 断线重连机制
    3. 异常数据过滤
    4. 重复订阅幂等性
    5. 配置错误处理
    6. 性能基准测试
    """
    
    @pytest.fixture
    def mock_config(self):
        """模拟配置对象
        
        为什么使用fixture：提供可重用的测试数据，避免重复代码
        
        Returns:
            Dict: 模拟的网关配置字典
        """
        # 这里将在实现后替换为真实配置
        ctp_config = {
            "front_addr": "tcp://180.168.146.187:10131",
            "broker_id": "9999",
            "user_id": "test_user",
            "password": "test_password",
            "connect_timeout": 10,
            "heartbeat_interval": 30
        }
        
        gateway_config = {
            "name": "TestGateway",
            "enabled": True,
            "ctp": ctp_config,
            "max_reconnect_attempts": 3,
            "max_backoff_seconds": 60,
            "initial_backoff_seconds": 1,
            # 其他配置参数...
        }
        
        return gateway_config
    
    @pytest.fixture
    def sample_ctp_tick_data(self):
        """模拟CTP格式的Tick数据
        
        为什么使用fixture：提供标准化的测试数据，确保测试一致性
        
        Returns:
            Dict: 模拟的CTP Tick数据字典
        """
        return {
            "InstrumentID": TEST_SYMBOL,
            "ExchangeID": TEST_EXCHANGE,
            "LastPrice": float(TEST_PRICE),
            "Volume": TEST_VOLUME,
            "Turnover": 3000000.0,
            "OpenInterest": 5000,
            "BidPrice1": float(TEST_PRICE - Decimal("1.0")),
            "AskPrice1": float(TEST_PRICE + Decimal("1.0")),
            "BidVolume1": 10,
            "AskVolume1": 15,
            "UpperLimitPrice": 3200.0,
            "LowerLimitPrice": 2800.0,
            "UpdateTime": "15:00:00",
            "UpdateMillisec": 500,
            "TradingDay": "20231201",
            "ActionDay": "20231201"
        }
    
    @pytest.fixture
    def mock_gateway(self, mock_config):
        """模拟网关实例
        
        为什么使用fixture：提供预配置的网关实例，简化测试设置
        
        Args:
            mock_config: 注入的模拟配置
            
        Yields:
            CtpMarketGateway: 模拟的网关实例
        """
        # 直接创建网关实例，不需要模拟CTP API
        gateway = CtpMarketGateway(mock_config)
        gateway._event_queue = AsyncMock()
        
        # RISK: 模拟API可能无法完全反映真实行为
        # 为什么模拟API：隔离外部依赖，确保测试稳定性
        gateway.api = Mock()
        gateway.api.SubscribeMarketData = Mock(return_value=True)
        gateway.api.UnSubscribeMarketData = Mock(return_value=True)
        
        yield gateway
    
    @pytest.mark.asyncio
    async def test_normal_tick_data_conversion(self, mock_gateway, sample_ctp_tick_data):
        """测试正常行情推送（验证TickData转换）
        
        测试目的：验证有效的CTP Tick数据能正确转换为标准TickData对象
        
        Arrange: 准备有效的CTP Tick数据和模拟网关
        Act: 调用on_tick方法处理数据
        Assert: 验证TickData对象创建成功且字段正确
        """
        # Arrange
        gateway = mock_gateway
        ctp_data = sample_ctp_tick_data
        
        # Act
        result = await gateway.on_tick(ctp_data)
        
        # Assert
        assert isinstance(result, TickData), "应该返回TickData对象"
        assert result.symbol == TEST_SYMBOL, f"合约代码应为{TEST_SYMBOL}"
        assert result.exchange == TEST_EXCHANGE, f"交易所应为{TEST_EXCHANGE}"
        assert result.last_price == TEST_PRICE, f"最新价应为{TEST_PRICE}"
        assert result.volume == TEST_VOLUME, f"成交量应为{TEST_VOLUME}"
        assert result.bid_price_1 == TEST_PRICE - Decimal("1.0"), "买一价应为2999.0"
        assert result.ask_price_1 == TEST_PRICE + Decimal("1.0"), "卖一价应为3001.0"
        assert result.is_valid is True, "数据应为有效状态"
    
    @pytest.mark.asyncio
    async def test_reconnect_exponential_backoff(self, mock_gateway):
        """测试断线重连（模拟断线3次，验证指数退避间隔）
        
        测试目的：验证网关在连接断开时能够按照指数退避策略进行重连
        
        Arrange: 模拟连接断开并准备重连尝试
        Act: 触发重连机制
        Assert: 验证重连尝试次数和时间间隔符合指数退避策略
        """
        # Arrange
        gateway = mock_gateway
        gateway.status = GatewayStatus.DISCONNECTED
        gateway.should_reconnect = True
        gateway.reconnect_attempts = 0
        
        # RISK: 重连逻辑错误可能导致无限循环
        # 为什么模拟连接方法：控制重连行为，确保测试可预测
        connect_attempts = 0

        async def mock_connect():
            nonlocal connect_attempts
            connect_attempts += 1
            if connect_attempts < 3:
                raise ConnectionError("Connection failed")
            return True
        
        gateway.connect = mock_connect
        
        # Act
        # RISK: mock_sleep可能无法完全模拟真实的时间等待行为
        with patch('asyncio.sleep', new_callable=AsyncMock) as mock_sleep:
            reconnect_result = await gateway.reconnect()
        
        # Assert
        assert reconnect_result is True, "重连应该成功"
        assert connect_attempts == 3, "应该尝试连接3次"
        # 验证指数退避时间间隔 (1s, 2s)
        assert mock_sleep.call_count == 2, "应该调用sleep 2次"
        mock_sleep.assert_any_call(1)  # 第一次退避
        mock_sleep.assert_any_call(2)  # 第二次退避
    
    @pytest.mark.asyncio
    async def test_invalid_data_filtering(self, mock_gateway):
        """测试异常数据过滤（price=-1）

        Arrange: 准备无效的CTP Tick数据（价格为负数）
        Act: 调用on_tick方法处理数据
        Assert: 验证无效数据被过滤，不产生TickData对象
        """
        # Arrange
        gateway = mock_gateway

        # 测试价格为-1的情况
        invalid_tick_data_price = {
            "InstrumentID": "rb2401",
            "ExchangeID": "SHFE",
            "LastPrice": -1,  # 无效价格
            "Volume": 1000,
            "Turnover": 3000000.0,
            "OpenInterest": 5000,
            "UpdateTime": "15:00:00",
            "UpdateMillisec": 500,
            "TradingDay": "20231201",
            "ActionDay": "20231201"
        }

        # 测试缺少必要字段的情况
        invalid_tick_data_missing = {
            "InstrumentID": "rb2401",
            "ExchangeID": "SHFE",
            # 缺少 LastPrice
            "Volume": 1000,
            "Turnover": 3000000.0,
            "OpenInterest": 5000,
            "UpdateTime": "15:00:00",
            "UpdateMillisec": 500,
            "TradingDay": "20231201",
            "ActionDay": "20231201"
        }

        # Act
        result_price = await gateway.on_tick(invalid_tick_data_price)
        result_missing = await gateway.on_tick(invalid_tick_data_missing)

        # Assert
        assert result_price is None  # 无效价格应该被过滤
        assert result_missing is None  # 缺少必要字段应该被过滤
    
    @pytest.mark.asyncio
    async def test_duplicate_subscription_idempotency(self, mock_gateway):
        """测试重复订阅幂等性
        
        Arrange: 准备模拟网关和合约列表
        Act: 多次订阅同一合约
        Assert: 验证订阅结果一致，不会重复订阅
        """
        # Arrange
        gateway = mock_gateway
        symbols = ["rb2401", "cu2401"]
        
        # Act
        result1 = await gateway.subscribe(symbols)
        result2 = await gateway.subscribe(symbols)  # 重复订阅
        
        # Assert
        assert result1 == result2
        # 验证订阅列表中不重复
        assert len(gateway.subscribed_symbols) == len(symbols)
        assert all(symbol in gateway.subscribed_symbols for symbol in symbols)
    
    @pytest.mark.asyncio
    async def test_config_error_handling(self, mock_config):
        """测试配置错误（错误服务器地址）
        
        Arrange: 准备错误的配置（无效服务器地址）
        Act: 尝试初始化网关
        Assert: 验证初始化失败并抛出适当异常
        """
        # Arrange - 使用深拷贝避免修改原始配置
        invalid_config = copy.deepcopy(mock_config)
        invalid_config["ctp"]["front_addr"] = "invalid_address"  # 无效地址格式
        
        # Act & Assert
        with pytest.raises(ConfigError):
            CtpMarketGateway(invalid_config)
    
    @pytest.mark.benchmark
    def test_tick_processing_performance(self, mock_gateway, sample_ctp_tick_data, benchmark):
        """测试Tick数据处理性能（目标<1ms/次）
        
        Arrange: 准备有效的CTP Tick数据和模拟网关
        Act: 使用benchmark测试on_tick方法性能
        Assert: 验证处理时间小于1ms
        """
        # Arrange
        gateway = mock_gateway
        ctp_data = sample_ctp_tick_data
        
        # Act & Assert - 创建新的异步函数每次执行
        def process_tick():
            return asyncio.run(gateway.on_tick(ctp_data))
        
        result = benchmark(process_tick)
        assert isinstance(result, TickData)

__all__ = ['TestCtpMarketGateway']