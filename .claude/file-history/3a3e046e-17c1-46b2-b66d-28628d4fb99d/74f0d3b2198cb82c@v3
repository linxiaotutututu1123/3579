"""网关工厂实现

提供统一的网关创建接口，支持多种类型的行情网关。
"""

import logging
from typing import Dict, Any, Optional, Type, List
from .base import MarketGateway
from .ctp_gateway import CtpMarketGateway
from .exceptions import ConfigError

logger = logging.getLogger(__name__)

# 工厂类常量定义
DEFAULT_GATEWAY_NAME = "unnamed"  # 默认网关名称
MAX_TYPE_LENGTH = 50  # 网关类型名称最大长度


class GatewayFactory:
    """网关工厂类

    根据配置创建不同类型的行情网关实例。
    支持动态注册新的网关类型。

    使用示例:
        # 创建CTP网关
        config = {"name": "my_gateway", "type": "ctp", ...}
        gateway = GatewayFactory.create_gateway(config)

        # 注册自定义网关类型
        GatewayFactory.register_gateway_type("custom", CustomGateway)
    """

    # 支持的网关类型映射
    _gateway_types: Dict[str, Type[MarketGateway]] = {
        "ctp": CtpMarketGateway,
        # 可以在这里添加其他类型的网关
        # "ib": IbMarketGateway,
        # "binance": BinanceMarketGateway,
    }

    def __repr__(self) -> str:
        """返回工厂类的字符串表示
        
        Returns:
            str: 类名和当前注册的网关类型数量
        """
        return f"{self.__class__.__name__}(registered_types={len(self._gateway_types)})"

    @classmethod
    def create_gateway(cls, config: Dict[str, Any]) -> MarketGateway:
        """根据配置创建网关实例

        Args:
            config: 网关配置字典，必须包含 'type' 字段

        Returns:
            MarketGateway: 网关实例

        Raises:
            ValueError: 当配置缺少 'type' 字段或网关类型不支持时
            ConfigError: 当配置验证失败时
        """
        # 检查必需的type字段 # REVIEW: 确保配置包含必需的类型字段以避免后续错误
        if "type" not in config:
            error_msg = "Gateway configuration must include 'type' field"
            logger.error(error_msg)
            raise ValueError(error_msg)

        # 转换为小写以实现大小写不敏感 # REVIEW: 统一处理大小写提高容错性
        gateway_type = config["type"].lower()

        # 查找对应的网关类 # REVIEW: 通过类型映射获取具体实现类
        gateway_class = cls._gateway_types.get(gateway_type)
        if gateway_class is None:
            # 构造详细的错误信息 # REVIEW: 提供明确的错误信息帮助用户诊断问题
            supported = ", ".join(cls._gateway_types.keys())
            error_msg = f"Unsupported gateway type: '{gateway_type}'. Supported types: {supported}"
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            # 创建网关实例 # REVIEW: 使用配置初始化具体的网关实例
            gateway = gateway_class(config)
            # 记录成功创建的日志 # REVIEW: 提供操作审计跟踪
            gateway_name = config.get('name', DEFAULT_GATEWAY_NAME)
            logger.info(f"Created {gateway_type} gateway: {gateway_name}")
            return gateway

        except ConfigError:
            # 直接抛出配置错误 # REVIEW: 保持配置错误的原始上下文
            raise
        except Exception as e:
            # 捕获并包装其他异常 # REVIEW: 提供统一的错误处理界面
            logger.error(f"Failed to create {gateway_type} gateway: {str(e)}")
            raise ConfigError(f"Gateway creation failed: {str(e)}")

    @classmethod
    def register_gateway_type(
        cls,
        gateway_type: str,
        gateway_class: Type[MarketGateway]
    ) -> None:
        """注册新的网关类型

        Args:
            gateway_type: 网关类型名称（大小写不敏感）
            gateway_class: 网关类，必须是 MarketGateway 的子类

        Raises:
            TypeError: 当 gateway_class 不是 MarketGateway 的子类时
            ValueError: 当 gateway_type 为空或过长时
        """
        # 验证类型名称有效性 # REVIEW: 防止无效或恶意的类型名称注册
        if not gateway_type or not gateway_type.strip():
            raise ValueError("Gateway type cannot be empty")
        
        # 限制类型名称长度防止滥用 # REVIEW: 控制输入长度避免内存问题
        stripped_type = gateway_type.strip()
        if len(stripped_type) > MAX_TYPE_LENGTH:
            raise ValueError(f"Gateway type exceeds maximum length of {MAX_TYPE_LENGTH}")

        # 验证类是否为MarketGateway的子类 # REVIEW: 确保类型安全性
        if not (isinstance(gateway_class, type) and issubclass(gateway_class, MarketGateway)):
            raise TypeError(
                f"gateway_class must be a subclass of MarketGateway, "
                f"got {type(gateway_class).__name__}"
            )

        # 转换为小写并注册 # REVIEW: 统一大小写处理实现不区分大小写的查找
        type_lower = stripped_type.lower()
        cls._gateway_types[type_lower] = gateway_class
        logger.info(f"Registered gateway type: {type_lower}")

    @classmethod
    def unregister_gateway_type(cls, gateway_type: str) -> bool:
        """取消注册网关类型

        Args:
            gateway_type: 网关类型名称

        Returns:
            bool: 是否成功取消注册
        """
        # 转换为小写进行查找 # REVIEW: 保持与注册时一致的大小写处理
        type_lower = gateway_type.lower().strip()
        if type_lower in cls._gateway_types:
            # 删除类型映射 # REVIEW: 释放不再需要的资源
            del cls._gateway_types[type_lower]
            logger.info(f"Unregistered gateway type: {type_lower}")
            return True
        # 类型不存在时返回False # REVIEW: 提供明确的操作结果反馈
        return False

    @classmethod
    def get_supported_types(cls) -> List[str]:
        """获取支持的网关类型列表

        Returns:
            List[str]: 支持的网关类型名称列表
        """
        # 返回当前注册的所有类型 # REVIEW: 提供查询接口方便外部使用
        return list(cls._gateway_types.keys())

    @classmethod
    def is_type_supported(cls, gateway_type: str) -> bool:
        """检查网关类型是否支持

        Args:
            gateway_type: 网关类型名称

        Returns:
            bool: 是否支持该类型
        """
        # 转换为小写进行查找 # REVIEW: 实现大小写不敏感的类型检查
        return gateway_type.lower().strip() in cls._gateway_types

    @classmethod
    def get_gateway_class(cls, gateway_type: str) -> Optional[Type[MarketGateway]]:
        """获取网关类

        Args:
            gateway_type: 网关类型名称

        Returns:
            Type[MarketGateway]: 网关类，如果不存在则返回None
        """
        # 转换为小写进行查找 # REVIEW: 保持一致性处理
        return cls._gateway_types.get(gateway_type.lower().strip())


__all__ = ['GatewayFactory']