"""
网关配置模型

提供CTP网关和相关组件的配置验证和管理。
"""

import re
from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import List, Optional, Dict, Any


# CTP前置地址正则表达式
CTP_FRONT_ADDR_PATTERN = re.compile(r'^tcp://[\w.-]+:\d+$')


class CtpConfig(BaseModel):
    """CTP连接配置模型

    用于配置CTP行情接口的连接参数。

    Attributes:
        front_addr: CTP前置服务器地址，格式为 tcp://host:port
        broker_id: 期货公司代码
        user_id: 用户ID
        password: 登录密码
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,  # 自动去除字符串首尾空白
        validate_default=True,  # 验证默认值
    )

    # 连接信息
    front_addr: str = Field(..., description="CTP前置服务器地址，格式: tcp://host:port")
    broker_id: str = Field(..., min_length=1, max_length=16, description="期货公司ID")
    user_id: str = Field(..., min_length=1, max_length=32, description="用户ID")
    password: str = Field(..., min_length=1, description="密码")
    app_id: Optional[str] = Field(None, max_length=64, description="应用ID（穿透式监管）")
    auth_code: Optional[str] = Field(None, max_length=64, description="认证码（穿透式监管）")

    # 连接参数
    connect_timeout: int = Field(default=10, ge=1, le=300, description="连接超时时间（秒）")
    heartbeat_interval: int = Field(default=30, ge=5, le=300, description="心跳间隔（秒）")

    @field_validator('front_addr', mode='before')
    @classmethod
    def validate_front_addr(cls, v: Any) -> str:
        """验证前置地址格式

        Args:
            v: 待验证的地址值

        Returns:
            str: 验证通过的地址

        Raises:
            ValueError: 地址格式无效时
        """
        if not v:
            raise ValueError("前置地址不能为空")

        v_str = str(v).strip()

        if not CTP_FRONT_ADDR_PATTERN.match(v_str):
            raise ValueError(
                f"前置地址格式无效: '{v_str}'，"
                f"应为 'tcp://host:port' 格式，如 'tcp://180.168.146.187:10131'"
            )

        # 验证端口范围
        port_str = v_str.split(':')[-1]
        port = int(port_str)
        if not (1 <= port <= 65535):
            raise ValueError(f"端口号必须在1-65535之间，当前为: {port}")

        return v_str

    def get_masked_password(self) -> str:
        """获取掩码后的密码（用于日志）"""
        if not self.password:
            return ""
        return self.password[0] + "*" * (len(self.password) - 2) + self.password[-1] if len(self.password) > 2 else "***"


class GatewayConfig(BaseModel):
    """网关配置模型

    用于配置行情网关的各项参数。

    Attributes:
        name: 网关名称
        type: 网关类型（如 ctp, ib 等）
        enabled: 是否启用
        ctp: CTP连接配置
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_default=True,
    )

    # 基本配置
    name: str = Field(default="CtpMarketGateway", min_length=1, max_length=64, description="网关名称")
    type: str = Field(default="ctp", min_length=1, max_length=32, description="网关类型")
    enabled: bool = Field(default=True, description="是否启用")

    # CTP配置
    ctp: CtpConfig = Field(..., description="CTP连接配置")

    # 重连配置
    max_reconnect_attempts: int = Field(default=0, ge=0, description="最大重连次数，0表示无限次")
    max_backoff_seconds: int = Field(default=60, ge=1, le=3600, description="最大退避时间（秒）")
    initial_backoff_seconds: int = Field(default=1, ge=1, le=60, description="初始退避时间（秒）")

    # 订阅配置
    max_subscriptions: int = Field(default=1000, ge=1, le=10000, description="最大订阅合约数量")
    subscription_timeout: int = Field(default=5, ge=1, le=60, description="订阅超时时间（秒）")

    # 数据缓存配置
    cache_duration_seconds: int = Field(default=30, ge=0, le=3600, description="数据缓存时间（秒）")
    max_cache_size: int = Field(default=10000, ge=100, le=1000000, description="最大缓存条目数")

    # 数据清洗配置
    price_deviation_threshold: float = Field(default=0.1, ge=0.01, le=1.0, description="价格偏差阈值（比例）")
    timestamp_tolerance_hours: int = Field(default=1, ge=0, le=24, description="时间戳容错（小时）")

    # 性能配置
    max_ticks_per_second: int = Field(default=5000, ge=100, le=100000, description="每秒最大处理Tick数")
    batch_size: int = Field(default=100, ge=1, le=10000, description="批处理大小")

    # 告警配置
    dingtalk_webhook: Optional[str] = Field(None, description="钉钉告警Webhook URL")
    alert_cooldown_seconds: int = Field(default=300, ge=0, le=86400, description="告警冷却时间（秒）")

    # Redis配置
    redis_host: str = Field(default="localhost", description="Redis主机")
    redis_port: int = Field(default=6379, ge=1, le=65535, description="Redis端口")
    redis_db: int = Field(default=0, ge=0, le=15, description="Redis数据库")
    redis_password: Optional[str] = Field(None, description="Redis密码")

    # ClickHouse配置
    clickhouse_host: str = Field(default="localhost", description="ClickHouse主机")
    clickhouse_port: int = Field(default=9000, ge=1, le=65535, description="ClickHouse端口")
    clickhouse_database: str = Field(default="market_data", min_length=1, description="ClickHouse数据库名")
    clickhouse_table: str = Field(default="tick_data", min_length=1, description="ClickHouse表名")
    clickhouse_user: Optional[str] = Field(None, description="ClickHouse用户名")
    clickhouse_password: Optional[str] = Field(None, description="ClickHouse密码")

    @field_validator('initial_backoff_seconds')
    @classmethod
    def validate_initial_backoff(cls, v: int) -> int:
        """验证初始退避时间不大于最大退避时间"""
        # 注意：在 Pydantic V2 中，跨字段验证应使用 model_validator
        return v

    def to_safe_dict(self) -> Dict[str, Any]:
        """转换为安全的字典（隐藏敏感信息）

        Returns:
            Dict[str, Any]: 不包含敏感信息的配置字典
        """
        data = self.model_dump()
        # 隐藏密码
        if 'ctp' in data and 'password' in data['ctp']:
            data['ctp']['password'] = '******'
        if data.get('redis_password'):
            data['redis_password'] = '******'
        if data.get('clickhouse_password'):
            data['clickhouse_password'] = '******'
        return data


class KLineConfig(BaseModel):
    """K线生成配置

    用于配置K线的生成参数和存储方式。
    """

    model_config = ConfigDict(
        validate_default=True,
    )

    # K线周期（分钟）
    periods: List[int] = Field(default=[1, 5], description="K线周期（分钟）")

    # 生成策略
    generate_on_tick: bool = Field(default=True, description="是否在每个Tick时更新K线")
    generate_on_close: bool = Field(default=True, description="是否在K线收盘时生成")

    # 数据保存
    save_to_clickhouse: bool = Field(default=True, description="是否保存到ClickHouse")
    publish_to_redis: bool = Field(default=True, description="是否发布到Redis")

    @field_validator('periods', mode='before')
    @classmethod
    def validate_periods(cls, v: Any) -> List[int]:
        """验证K线周期

        Args:
            v: 待验证的周期列表

        Returns:
            List[int]: 排序后的有效周期列表

        Raises:
            ValueError: 周期无效时
        """
        if not v:
            raise ValueError("K线周期不能为空")

        if isinstance(v, (list, tuple)):
            periods = list(v)
        else:
            raise ValueError(f"K线周期必须是列表类型，当前为: {type(v).__name__}")

        # 验证每个周期
        for p in periods:
            if not isinstance(p, int) or p <= 0:
                raise ValueError(f"K线周期必须为正整数，当前为: {p}")
            if p > 1440:
                raise ValueError(f"K线周期不能超过1440分钟（1天），当前为: {p}")

        return sorted(set(periods))  # 去重并排序


__all__ = ['CtpConfig', 'GatewayConfig', 'KLineConfig']