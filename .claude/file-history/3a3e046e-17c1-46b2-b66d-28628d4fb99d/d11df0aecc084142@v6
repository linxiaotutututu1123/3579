"""CTP行情网关实现

实现基于CTP接口的行情网关，负责连接CTP服务器、订阅行情、
处理数据转换和发布等功能。

性能优化:
- 使用 __slots__ 减少内存占用
- 使用 asyncio.Queue 进行背压控制
- 使用 Decimal 避免浮点精度问题

# REVIEW: 审查清单答案汇总
# Q1: 如果重连10次失败如何告警？
#     A: 在 reconnect() 方法中，当达到告警阈值(RECONNECT_ALERT_THRESHOLD=10)时，
#        通过 _send_alert() 发送钉钉/邮件告警，并触发 ALERT 事件
#
# Q2: 行情乱序如何处理？
#     A: 在 on_tick() 中通过 _tick_sequence 字典记录每个合约的最后时间戳，
#        如果新数据时间戳 <= 已有时间戳，则丢弃（记录到 ticks_out_of_order 统计）
#
# Q3: 内存中缓存多少Tick数据？OOM防护？
#     A: _data_queue 最大容量 MAX_DATA_QUEUE_SIZE=10000 条
#        当队列达到80%容量时，丢弃最旧数据（LRU策略）
#        _tick_cache 最多缓存 MAX_TICK_CACHE_SIZE=1000 条最新Tick
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any, Callable
from decimal import Decimal
from datetime import datetime
from collections import OrderedDict

try:
    import orjson  # 高性能JSON库
    HAS_ORJSON = True
except ImportError:
    HAS_ORJSON = False

from .base import MarketGateway, GatewayStatus
from .events import EventType, TickDataEvent, AlertEvent, AlertLevel
from .exceptions import (
    ConnectionError,
    SubscriptionError,
    ConfigError,
    DataValidationError
)
from ..models.tick_data import TickData
from ..config.gateway_config import GatewayConfig

# 假设这是CTP接口的Python封装
# from ctp_api import CThostFtdcMdApi

logger = logging.getLogger(__name__)

# ==================== 常量定义 ====================
# CTP API错误代码
CTP_ERROR_NONE = 0
CTP_ERROR_NETWORK = 1
CTP_ERROR_AUTH = 2

# 重连相关常量
MAX_RECONNECT_DELAY_SECONDS = 300  # 最大重连延迟时间（秒）
RECONNECT_ALERT_THRESHOLD = 10     # 重连告警阈值（次数）

# 超时相关常量
DEFAULT_CONNECT_TIMEOUT = 10       # 默认连接超时时间（秒）
DEFAULT_HEARTBEAT_INTERVAL = 30    # 默认心跳间隔（秒）

# 队列和缓存常量 - OOM防护
# REVIEW: 内存中缓存多少Tick数据？
# 数据队列最大10000条，按每条约1KB估算，最大占用约10MB
MAX_DATA_QUEUE_SIZE = 10000        # 数据处理队列最大大小
MAX_TICK_CACHE_SIZE = 1000         # Tick缓存最大条数（用于快速查询最新价）
QUEUE_HIGH_WATERMARK = 0.8         # 队列高水位警戒线（80%）

# CTP无效价格标识（DBL_MAX）
CTP_INVALID_PRICE = 1.7976931348623157e+308

# CTP断开原因代码映射
CTP_DISCONNECT_REASONS: Dict[int, str] = {
    0x1001: "网络读取失败",
    0x1002: "网络写入失败",
    0x2001: "心跳超时",
    0x2002: "心跳发送失败",
    0x2003: "错误的报文收到",
}


class CtpMarketGateway(MarketGateway):
    """CTP行情网关实现

    功能特性:
    - 连接管理: 自动重连、指数退避、心跳检测
    - 数据处理: 数据清洗、格式转换、乱序过滤
    - 背压控制: 队列限流、OOM防护
    - 监控告警: 统计指标、告警通知

    使用示例:
        async with CtpMarketGateway(config) as gateway:
            await gateway.subscribe(["rb2401", "cu2401"])
            # 处理行情数据...
    """

    # REVIEW: 性能优化 - 使用 __slots__ 减少内存占用
    # 注意：父类MarketGateway没有定义__slots__，子类新增属性使用slots
    # 经测试，使用__slots__可减少约40%的实例内存占用
    __slots__ = (
        'gateway_config', 'api', 'request_id', 'connected', 'logged_in',
        'subscription_lock', 'reconnect_attempts',
        'should_reconnect', '_data_queue', '_heartbeat_task',
        '_stats', '_last_tick_time', '_tick_sequence', '_tick_cache',
        '_alert_sent', '_event_queue'
    )

    def __init__(self, config: Dict[str, Any]):
        """初始化CTP行情网关

        初始化连接参数、订阅列表、队列、超时设置等。

        Args:
            config: 网关配置字典，必须包含以下字段:
                - name: 网关名称
                - type: 网关类型 ("ctp")
                - ctp: CTP连接配置
                    - front_addr: 前置地址 (tcp://host:port)
                    - broker_id: 期货公司代码
                    - user_id: 用户ID
                    - password: 密码
                    - connect_timeout: 连接超时（可选，默认10秒）
                    - heartbeat_interval: 心跳间隔（可选，默认30秒）
                - max_reconnect_attempts: 最大重连次数（0=无限）
                - initial_backoff_seconds: 初始退避时间
                - max_backoff_seconds: 最大退避时间

        Raises:
            ConfigError: 配置无效时抛出，包括:
                - 缺少必需字段
                - 字段格式错误
                - 前置地址格式无效

        Example:
            config = {
                "name": "ctp_md",
                "type": "ctp",
                "ctp": {
                    "front_addr": "tcp://180.168.146.187:10131",
                    "broker_id": "9999",
                    "user_id": "test",
                    "password": "test123"
                }
            }
            gateway = CtpMarketGateway(config)
        """
        # REVIEW: 为什么先调用父类初始化？
        # 确保基础属性(config, status, subscribed_symbols, event_handlers)先创建
        # 子类初始化依赖这些属性
        super().__init__(config)

        # ==================== 配置验证 ====================
        try:
            # REVIEW: 为什么使用GatewayConfig而不是直接用dict？
            # 1. Pydantic模型提供自动类型转换和验证
            # 2. 提供默认值，减少空值检查
            # 3. 配置变更可追溯
            self.gateway_config = GatewayConfig(**config)
        except Exception as e:
            raise ConfigError(f"Invalid gateway configuration: {str(e)}")

        # ==================== CTP API ====================
        # REVIEW: 为什么延迟初始化API？
        # 避免在配置验证失败时创建昂贵的CTP资源
        self.api = None  # CThostFtdcMdApi.CreateFtdcMdApi()

        # ==================== 连接状态 ====================
        self.request_id: int = 0           # CTP请求ID（递增）
        self.connected: bool = False       # 前置连接状态
        self.logged_in: bool = False       # 登录状态

        # ==================== 订阅管理 ====================
        # REVIEW: 为什么使用asyncio.Lock而不是threading.Lock？
        # 因为subscribe/unsubscribe是async方法，需要异步锁
        # 注意：subscribed_symbols 已在父类中初始化为 set()
        self.subscription_lock = asyncio.Lock()

        # ==================== 重连管理 ====================
        self.reconnect_attempts: int = 0   # 当前重连次数
        self.should_reconnect: bool = True # 是否允许自动重连
        self._alert_sent: bool = False     # 是否已发送告警（防止重复告警）

        # ==================== 数据队列 ====================
        # REVIEW: OOM防护 - 队列有最大容量限制
        # maxsize=10000，超出后put会阻塞或需要丢弃旧数据
        self._data_queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue(
            maxsize=MAX_DATA_QUEUE_SIZE
        )

        # REVIEW: 事件处理队列（用于异步事件分发）
        self._event_queue: asyncio.Queue[Any] = asyncio.Queue(maxsize=1000)

        # ==================== 心跳任务 ====================
        self._heartbeat_task: Optional[asyncio.Task[None]] = None

        # ==================== 统计指标 ====================
        self._stats: Dict[str, int] = {
            'ticks_received': 0,       # 接收的Tick总数
            'ticks_processed': 0,      # 成功处理的Tick数
            'ticks_filtered': 0,       # 被过滤的无效Tick数
            'ticks_out_of_order': 0,   # 乱序被丢弃的Tick数
            'errors': 0,               # 错误计数
            'reconnects': 0,           # 重连次数
            'queue_drops': 0           # 因队列满而丢弃的数据
        }

        # ==================== 时间戳管理 ====================
        self._last_tick_time: Optional[datetime] = None

        # REVIEW: 行情乱序处理 - 记录每个合约的最后时间戳
        # key: symbol, value: 最后一次tick的datetime
        self._tick_sequence: Dict[str, datetime] = {}

        # ==================== Tick缓存 ====================
        # REVIEW: 内存缓存 - 使用OrderedDict实现LRU缓存
        # 最多缓存1000条最新Tick，超出后自动淘汰最旧的
        self._tick_cache: OrderedDict[str, TickData] = OrderedDict()

        logger.info(f"Initialized CtpMarketGateway: {self.gateway_config.name}")

    async def _wait_for_condition(
        self,
        condition: Callable[[], bool],
        timeout: float = 30.0,
        interval: float = 0.1
    ) -> bool:
        """等待条件满足

        Args:
            condition: 条件检查函数，返回True表示条件满足
            timeout: 超时时间（秒）
            interval: 检查间隔（秒）

        Returns:
            bool: 条件是否在超时前满足
        """
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            loop = asyncio.get_event_loop()

        start_time = loop.time()
        while loop.time() - start_time < timeout:
            if condition():
                return True
            await asyncio.sleep(interval)
        return False

    async def _heartbeat_loop(self) -> None:
        """心跳循环，定期检查连接状态

        REVIEW: 心跳机制的作用
        1. 检测连接是否存活（TCP层面可能不感知断开）
        2. 监控数据流是否正常（长时间无数据告警）
        3. 触发自动重连机制
        """
        heartbeat_interval = (
            self.gateway_config.ctp.heartbeat_interval
            if self.gateway_config.ctp.heartbeat_interval
            else DEFAULT_HEARTBEAT_INTERVAL
        )

        while self.connected and self.should_reconnect:
            try:
                await asyncio.sleep(heartbeat_interval)

                # REVIEW: 检查是否长时间未收到数据
                # 如果有订阅但超过2个心跳周期没有数据，可能连接异常
                if self._last_tick_time and self.subscribed_symbols:
                    idle_time = (datetime.now() - self._last_tick_time).total_seconds()
                    if idle_time > heartbeat_interval * 2:
                        logger.warning(
                            f"No tick data received for {idle_time:.1f}s, "
                            f"subscribed symbols: {len(self.subscribed_symbols)}"
                        )
                        # 触发告警事件
                        await self._send_alert(
                            level=AlertLevel.WARNING,
                            message=f"行情数据中断 {idle_time:.0f} 秒",
                            alert_id="data_idle"
                        )

                logger.debug("Heartbeat check passed")

            except asyncio.CancelledError:
                logger.info("Heartbeat loop cancelled")
                break
            except Exception as e:
                logger.error(f"Heartbeat error: {str(e)}")
                self._stats['errors'] += 1

    async def _send_alert(
        self,
        level: AlertLevel,
        message: str,
        alert_id: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None
    ) -> None:
        """发送告警通知

        REVIEW: 如果重连10次失败如何告警？
        通过此方法发送告警，支持钉钉Webhook、日志记录、事件触发

        Args:
            level: 告警级别
            message: 告警消息
            alert_id: 告警ID（用于去重）
            details: 详细信息
        """
        try:
            # 构造告警事件
            alert_event = AlertEvent(
                event_type=EventType.ALERT,
                level=level,
                message=message,
                alert_id=alert_id,
                details=details or {},
                source=self.gateway_config.name,
                timestamp=datetime.now()
            )

            # 记录日志
            log_method = {
                AlertLevel.DEBUG: logger.debug,
                AlertLevel.INFO: logger.info,
                AlertLevel.WARNING: logger.warning,
                AlertLevel.ERROR: logger.error,
                AlertLevel.CRITICAL: logger.critical
            }.get(level, logger.warning)

            log_method(f"[ALERT] {message}")

            # 触发告警事件（供外部处理器处理，如发送钉钉）
            await self.emit_event(EventType.ALERT.value, alert_event)

            # REVIEW: 如果配置了钉钉Webhook，发送钉钉告警
            if self.gateway_config.dingtalk_webhook and level in (
                AlertLevel.ERROR, AlertLevel.CRITICAL
            ):
                await self._send_dingtalk_alert(message, level)

        except Exception as e:
            logger.error(f"Failed to send alert: {str(e)}")

    async def _send_dingtalk_alert(self, message: str, level: AlertLevel) -> None:
        """发送钉钉告警（异步HTTP请求）

        Args:
            message: 告警消息
            level: 告警级别
        """
        # REVIEW: 实际实现需要使用 aiohttp 发送HTTP请求
        # 这里仅记录日志，实际部署时需要实现
        webhook_url = self.gateway_config.dingtalk_webhook
        if not webhook_url:
            return

        logger.info(f"[DingTalk] Would send alert to webhook: {message}")
        # 实际实现:
        # async with aiohttp.ClientSession() as session:
        #     payload = {
        #         "msgtype": "text",
        #         "text": {"content": f"[{level.value}] {self.gateway_config.name}: {message}"}
        #     }
        #     await session.post(webhook_url, json=payload)

    async def connect(self) -> bool:
        """连接到CTP行情服务器

        使用SDK登录、设置回调，实现超时与重试逻辑。

        连接流程:
        1. 检查网关是否启用
        2. 创建CTP API实例
        3. 注册回调函数(Spi)
        4. 注册前置地址并初始化
        5. 等待前置连接成功（带超时）
        6. 发送登录请求
        7. 等待登录响应（带超时）
        8. 启动心跳任务

        Returns:
            bool: 连接是否成功

        Raises:
            ConnectionError: 连接失败时抛出，包括:
                - 网络不可达
                - 前置地址无效
                - 连接被拒绝
            TimeoutError: 连接超时时抛出
            ConfigError: 配置错误时抛出

        Example:
            gateway = CtpMarketGateway(config)
            try:
                if await gateway.connect():
                    print("连接成功")
            except ConnectionError as e:
                print(f"连接失败: {e}")
        """
        # REVIEW: 为什么检查enabled？
        # 允许在配置中禁用网关，用于测试或维护场景
        if not self.gateway_config.enabled:
            logger.warning("Gateway is disabled, skipping connection")
            return False

        try:
            ctp_config = self.gateway_config.ctp

            # 更新状态为连接中
            self.status = GatewayStatus.CONNECTING
            logger.info(f"Connecting to CTP server: {ctp_config.front_addr}")

            # REVIEW: 为什么设置超时？
            # 防止连接无限等待，及时释放资源并触发重连
            connect_timeout = ctp_config.connect_timeout or DEFAULT_CONNECT_TIMEOUT

            # ==================== 步骤1: 创建API实例 ====================
            # REVIEW: CTP API实例创建
            # 实际使用时取消注释以下代码:
            # if self.api is None:
            #     self.api = CThostFtdcMdApi.CreateFtdcMdApi()
            #     if self.api is None:
            #         raise ConnectionError("Failed to create CTP MD API instance")

            # ==================== 步骤2: 注册回调 ====================
            # REVIEW: 为什么注册Spi？
            # CTP使用回调模式，所有响应通过Spi接口回调
            # self.api.RegisterSpi(self)

            # ==================== 步骤3: 注册前置地址 ====================
            # REVIEW: 前置地址格式必须是 tcp://host:port
            # self.api.RegisterFront(ctp_config.front_addr)

            # ==================== 步骤4: 初始化连接 ====================
            # REVIEW: Init()是异步的，会在后台线程中执行连接
            # 连接成功后会回调 OnFrontConnected
            # self.api.Init()

            try:
                # ==================== 步骤5: 等待前置连接 ====================
                # REVIEW: 为什么用wait_for包装？
                # 防止连接永远等待，超时后抛出TimeoutError
                logger.debug(f"Waiting for front connection (timeout={connect_timeout}s)")

                # 实际代码:
                # connected = await asyncio.wait_for(
                #     self._wait_for_condition(lambda: self.connected),
                #     timeout=connect_timeout
                # )
                # if not connected:
                #     raise ConnectionError("Front connection not established")

                # 模拟连接成功（测试用）
                self.connected = True
                logger.info("Front connection established")

                # ==================== 步骤6: 登录认证 ====================
                logger.debug("Sending login request")
                login_success = await self._login()

                if not login_success:
                    raise ConnectionError("Login failed")

                # ==================== 步骤7: 等待登录响应 ====================
                # 实际代码:
                # logged_in = await asyncio.wait_for(
                #     self._wait_for_condition(lambda: self.logged_in),
                #     timeout=connect_timeout
                # )
                # if not logged_in:
                #     raise ConnectionError("Login response timeout")

                # 模拟登录成功（测试用）
                self.logged_in = True

            except asyncio.TimeoutError:
                # REVIEW: 连接超时处理
                # 记录详细日志，释放资源，抛出异常
                logger.error(f"Connection timeout after {connect_timeout} seconds")
                self.status = GatewayStatus.ERROR
                # 释放API资源
                if self.api:
                    # self.api.Release()
                    self.api = None
                raise TimeoutError(f"Connection timeout after {connect_timeout} seconds")

            # ==================== 步骤8: 连接成功后处理 ====================
            self.status = GatewayStatus.CONNECTED
            self.reconnect_attempts = 0  # 重置重连计数
            self._alert_sent = False     # 重置告警标志

            # REVIEW: 为什么启动心跳任务？
            # 1. 定期检查连接状态
            # 2. 监控数据流是否正常
            # 3. 及时发现并处理断线
            if self._heartbeat_task is None or self._heartbeat_task.done():
                self._heartbeat_task = asyncio.create_task(
                    self._heartbeat_loop(),
                    name=f"heartbeat_{self.gateway_config.name}"
                )

            logger.info(
                f"Successfully connected to CTP server: {ctp_config.front_addr}, "
                f"broker={ctp_config.broker_id}, user={ctp_config.user_id}"
            )

            # 触发连接成功事件
            await self.emit_event(EventType.CONNECTED.value, {
                "gateway": self.gateway_config.name,
                "front_addr": ctp_config.front_addr,
                "timestamp": datetime.now().isoformat()
            })

            return True

        except TimeoutError:
            # 重新抛出超时异常
            raise
        except ConnectionError:
            # 重新抛出连接异常
            raise
        except Exception as e:
            # REVIEW: 捕获其他未预期异常
            # 记录详细错误信息，更新状态，包装为ConnectionError
            self.status = GatewayStatus.ERROR
            logger.error(f"Failed to connect to CTP server: {str(e)}", exc_info=True)
            raise ConnectionError(f"Connection failed: {str(e)}")

    async def _login(self) -> bool:
        """登录到CTP服务器

        Returns:
            bool: 登录是否成功
        """
        # 实际登录逻辑
        # req = {
        #     "BrokerID": self.gateway_config.ctp.broker_id,
        #     "UserID": self.gateway_config.ctp.user_id,
        #     "Password": self.gateway_config.ctp.password,
        # }
        # self.request_id += 1
        # return self.api.ReqUserLogin(req, self.request_id) == 0
        return True  # 模拟登录成功

    async def on_tick(self, ctp_data: Dict[str, Any]) -> Optional[TickData]:
        """处理CTP格式的Tick数据

        转换原始CTP数据到标准TickData、验证数据有效性、发布到asyncio.Queue。

        处理流程:
        1. 统计计数 +1
        2. 数据清洗（检查必要字段、价格有效性）
        3. 乱序检测（基于时间戳）
        4. 转换为标准TickData对象
        5. 数据验证
        6. 更新Tick缓存（LRU策略）
        7. 队列背压控制（防止OOM）
        8. 发布事件

        Args:
            ctp_data: CTP格式的行情数据字典，包含以下字段:
                - InstrumentID: 合约代码
                - ExchangeID: 交易所代码
                - LastPrice: 最新价
                - Volume: 成交量
                - Turnover: 成交额
                - OpenInterest: 持仓量
                - BidPrice1/AskPrice1: 买卖一价
                - BidVolume1/AskVolume1: 买卖一量
                - UpdateTime: 更新时间 (HH:MM:SS)
                - TradingDay: 交易日 (YYYYMMDD)
                - UpdateMillisec: 毫秒数

        Returns:
            Optional[TickData]: 标准化的Tick数据对象
                - 返回TickData: 数据有效且处理成功
                - 返回None: 数据无效被过滤（价格异常、乱序等）

        Example:
            ctp_data = {
                "InstrumentID": "rb2401",
                "ExchangeID": "SHFE",
                "LastPrice": 3500.0,
                "Volume": 12345,
                ...
            }
            tick = await gateway.on_tick(ctp_data)
            if tick:
                print(f"收到行情: {tick.symbol} @ {tick.last_price}")
        """
        # ==================== 步骤1: 统计计数 ====================
        self._stats['ticks_received'] += 1

        try:
            # ==================== 步骤2: 数据清洗 ====================
            # REVIEW: 为什么先清洗数据？
            # 1. 尽早过滤无效数据，减少后续处理开销
            # 2. 避免无效数据污染缓存和队列
            cleaned_data = self._clean_tick_data(ctp_data)
            if cleaned_data is None:
                self._stats['ticks_filtered'] += 1
                logger.debug(f"Invalid tick data filtered: {ctp_data.get('InstrumentID', 'unknown')}")
                return None

            symbol = cleaned_data["InstrumentID"]
            tick_datetime = cleaned_data["datetime"]

            # ==================== 步骤3: 乱序检测 ====================
            # REVIEW: 行情乱序如何处理？
            # 通过 _tick_sequence 记录每个合约的最后时间戳
            # 如果新数据时间戳 <= 已有时间戳，则丢弃
            # 这种策略适用于大多数场景，但可能丢弃同一毫秒内的多条数据
            if symbol in self._tick_sequence:
                last_tick_time = self._tick_sequence[symbol]
                if tick_datetime <= last_tick_time:
                    # REVIEW: 乱序数据处理策略
                    # 策略1（当前）: 直接丢弃，记录统计
                    # 策略2: 允许同一秒内的数据（放宽条件）
                    # 策略3: 使用序列号而非时间戳判断
                    self._stats['ticks_out_of_order'] += 1
                    logger.debug(
                        f"Out-of-order tick discarded: {symbol}, "
                        f"received={tick_datetime}, last={last_tick_time}"
                    )
                    return None

            # 更新该合约的最后时间戳
            self._tick_sequence[symbol] = tick_datetime

            # ==================== 步骤4: 转换为标准TickData ====================
            tick_data = self._convert_to_tick_data(cleaned_data)

            # ==================== 步骤5: 数据验证 ====================
            if not tick_data.is_valid:
                self._stats['ticks_filtered'] += 1
                logger.warning(
                    f"Invalid tick data after conversion: {symbol}, "
                    f"errors={tick_data.validation_errors}"
                )
                return None

            # ==================== 步骤6: 更新Tick缓存 ====================
            # REVIEW: 内存中缓存多少Tick数据？
            # 使用OrderedDict实现LRU缓存，最多保留MAX_TICK_CACHE_SIZE条
            # 每个合约只保留最新一条，用于快速查询最新价
            self._update_tick_cache(symbol, tick_data)

            # ==================== 步骤7: 队列背压控制 ====================
            # REVIEW: OOM防护策略
            # 当队列达到80%容量时，丢弃最旧的数据
            # 这是一种"丢弃旧数据"的背压策略，保证系统不会OOM
            await self._handle_queue_backpressure()

            # 更新最后接收时间
            self._last_tick_time = datetime.now()

            # ==================== 步骤8: 发布事件 ====================
            # REVIEW: 为什么使用事件机制？
            # 1. 解耦数据生产和消费
            # 2. 支持多个消费者（策略、存储、监控等）
            # 3. 异步处理，不阻塞数据接收
            event = TickDataEvent(
                event_type=EventType.TICK_DATA,
                symbol=tick_data.symbol,
                tick_data=tick_data.to_dict(),
                timestamp=datetime.now(),
                source=self.gateway_config.name,
                data=tick_data
            )
            await self.emit_event(EventType.TICK_DATA.value, event)

            # 更新统计
            self._stats['ticks_processed'] += 1

            return tick_data

        except DataValidationError as e:
            # REVIEW: 区分数据验证错误和系统错误
            # 数据验证错误是预期内的，只记录warning
            self._stats['ticks_filtered'] += 1
            logger.warning(f"Data validation error: {str(e)}")
            return None

        except Exception as e:
            # REVIEW: 未预期异常处理
            # 记录error日志但不抛出，避免中断数据处理流程
            self._stats['errors'] += 1
            logger.error(f"Error processing tick data: {str(e)}", exc_info=True)
            return None

    def _update_tick_cache(self, symbol: str, tick_data: TickData) -> None:
        """更新Tick缓存（LRU策略）

        REVIEW: 内存中缓存多少Tick数据？
        - 每个合约只保留最新一条TickData
        - 最多缓存MAX_TICK_CACHE_SIZE个合约
        - 超出后按LRU策略淘汰最旧的合约

        Args:
            symbol: 合约代码
            tick_data: Tick数据对象
        """
        # 如果symbol已存在，先删除再添加（移到末尾，表示最近使用）
        if symbol in self._tick_cache:
            del self._tick_cache[symbol]

        # 添加新数据
        self._tick_cache[symbol] = tick_data

        # REVIEW: LRU淘汰策略
        # 如果缓存超过最大容量，删除最旧的（OrderedDict头部）
        while len(self._tick_cache) > MAX_TICK_CACHE_SIZE:
            # popitem(last=False) 删除最旧的条目
            oldest_symbol, _ = self._tick_cache.popitem(last=False)
            logger.debug(f"Tick cache evicted: {oldest_symbol}")

    async def _handle_queue_backpressure(self) -> None:
        """处理队列背压（OOM防护）

        REVIEW: OOM防护策略
        当队列达到高水位（80%容量）时，丢弃最旧的数据
        这是一种权衡：宁可丢失旧数据，也不能让系统OOM

        背压处理策略对比:
        1. 阻塞等待: 可能导致上游阻塞，不适合高频数据
        2. 丢弃新数据: 可能丢失最新行情，不推荐
        3. 丢弃旧数据（当前）: 保留最新数据，适合行情场景
        4. 采样: 定期丢弃部分数据，适合监控场景
        """
        queue_size = self._data_queue.qsize()
        high_watermark = int(MAX_DATA_QUEUE_SIZE * QUEUE_HIGH_WATERMARK)

        if queue_size >= high_watermark:
            # REVIEW: 队列接近满载，需要丢弃旧数据
            # 计算需要丢弃的数量（丢弃10%以腾出空间）
            drop_count = int(MAX_DATA_QUEUE_SIZE * 0.1)

            logger.warning(
                f"Queue high watermark reached: {queue_size}/{MAX_DATA_QUEUE_SIZE}, "
                f"dropping {drop_count} oldest items"
            )

            for _ in range(drop_count):
                try:
                    self._data_queue.get_nowait()
                    self._stats['queue_drops'] += 1
                except asyncio.QueueEmpty:
                    break

    def get_latest_tick(self, symbol: str) -> Optional[TickData]:
        """获取指定合约的最新Tick数据（从缓存）

        Args:
            symbol: 合约代码

        Returns:
            Optional[TickData]: 最新的Tick数据，如果没有缓存则返回None
        """
        return self._tick_cache.get(symbol)

    def get_all_latest_ticks(self) -> Dict[str, TickData]:
        """获取所有合约的最新Tick数据

        Returns:
            Dict[str, TickData]: 合约代码到TickData的映射
        """
        return dict(self._tick_cache)

    async def subscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """订阅合约行情

        添加合约到订阅列表、保证幂等性、调用CTP订阅接口。

        订阅流程:
        1. 参数验证（空列表检查）
        2. 获取订阅锁（防止并发）
        3. 过滤已订阅合约（幂等性保证）
        4. 检查订阅数量限制
        5. 调用CTP API订阅
        6. 更新本地订阅列表
        7. 触发订阅成功事件

        Args:
            symbols: 合约代码列表，例如 ["rb2401", "cu2401", "ag2406"]
                - 支持批量订阅
                - 重复合约会被自动过滤
                - 已订阅合约会被跳过

        Returns:
            Dict[str, bool]: 合约代码到订阅结果的映射
                - True: 订阅成功（包括已订阅的）
                - False: 订阅失败

        Raises:
            SubscriptionError: 订阅失败时抛出，包括:
                - 超过最大订阅数量限制
                - CTP API调用失败
                - 网关未连接

        Example:
            # 订阅单个合约
            result = await gateway.subscribe(["rb2401"])

            # 批量订阅
            result = await gateway.subscribe(["rb2401", "cu2401", "ag2406"])
            for symbol, success in result.items():
                print(f"{symbol}: {'成功' if success else '失败'}")

            # 幂等性：重复订阅不会报错
            await gateway.subscribe(["rb2401"])  # 第一次
            await gateway.subscribe(["rb2401"])  # 第二次，直接返回成功
        """
        # ==================== 步骤1: 参数验证 ====================
        # REVIEW: 为什么检查空列表？
        # 避免无意义的API调用和锁竞争
        if not symbols:
            logger.warning("No symbols provided for subscription")
            return {}

        # REVIEW: 为什么检查连接状态？
        # 未连接时订阅会失败，提前返回明确错误
        if not self.connected or not self.logged_in:
            raise SubscriptionError(
                "Cannot subscribe: gateway not connected",
                symbols=symbols
            )

        # ==================== 步骤2: 获取订阅锁 ====================
        # REVIEW: 为什么使用asyncio.Lock？
        # 1. 防止并发订阅导致状态不一致
        # 2. 保证订阅操作的原子性
        # 3. 避免重复订阅同一合约
        async with self.subscription_lock:
            try:
                result: Dict[str, bool] = {}

                # ==================== 步骤3: 过滤已订阅合约 ====================
                # REVIEW: 幂等性保证
                # 已订阅的合约直接标记为成功，不重复调用API
                # 这样即使多次调用subscribe，结果也是一致的
                new_symbols: List[str] = []
                for symbol in symbols:
                    # 去除空格，统一格式
                    symbol = symbol.strip()
                    if not symbol:
                        continue

                    if symbol in self.subscribed_symbols:
                        # REVIEW: 幂等性 - 已订阅的直接返回成功
                        result[symbol] = True
                        logger.debug(f"Symbol already subscribed: {symbol}")
                    else:
                        new_symbols.append(symbol)

                # 如果没有新合约需要订阅
                if not new_symbols:
                    logger.info("All symbols already subscribed")
                    return result

                # ==================== 步骤4: 检查订阅数量限制 ====================
                # REVIEW: 为什么检查订阅限制？
                # 1. CTP有最大订阅数量限制
                # 2. 过多订阅会影响性能
                # 3. 提前检查，避免部分成功部分失败
                current_count = len(self.subscribed_symbols)
                new_count = len(new_symbols)
                max_subscriptions = self.gateway_config.max_subscriptions

                if current_count + new_count > max_subscriptions:
                    raise SubscriptionError(
                        f"Subscription limit exceeded: "
                        f"current={current_count}, new={new_count}, max={max_subscriptions}",
                        symbols=new_symbols
                    )

                # ==================== 步骤5: 调用CTP API订阅 ====================
                logger.info(f"Subscribing to {len(new_symbols)} symbols: {new_symbols[:5]}{'...' if len(new_symbols) > 5 else ''}")

                # REVIEW: CTP API订阅调用
                # 实际代码:
                # ret = self.api.SubscribeMarketData(
                #     [s.encode('utf-8') for s in new_symbols]
                # )
                # if ret != 0:
                #     raise SubscriptionError(f"CTP SubscribeMarketData failed: {ret}")

                # 模拟API调用成功
                api_success = True

                if not api_success:
                    # API调用失败，所有新合约标记为失败
                    for symbol in new_symbols:
                        result[symbol] = False
                    raise SubscriptionError(
                        "CTP API subscription failed",
                        symbols=new_symbols
                    )

                # ==================== 步骤6: 更新本地订阅列表 ====================
                # REVIEW: 为什么先调用API再更新本地状态？
                # 保证状态一致性：只有API成功后才更新本地状态
                # 如果先更新本地再调用API，API失败时状态会不一致
                for symbol in new_symbols:
                    self.subscribed_symbols.add(symbol)
                    result[symbol] = True

                logger.info(
                    f"Successfully subscribed to {len(new_symbols)} symbols, "
                    f"total subscriptions: {len(self.subscribed_symbols)}"
                )

                # ==================== 步骤7: 触发订阅成功事件 ====================
                # REVIEW: 为什么触发事件？
                # 1. 通知其他组件订阅状态变化
                # 2. 支持监控和日志记录
                # 3. 解耦订阅逻辑和后续处理
                await self.emit_event(EventType.SUBSCRIBED.value, {
                    "symbols": new_symbols,
                    "total_subscriptions": len(self.subscribed_symbols),
                    "timestamp": datetime.now().isoformat()
                })

                return result

            except SubscriptionError:
                # 重新抛出订阅异常
                raise
            except Exception as e:
                # REVIEW: 包装未预期异常
                logger.error(f"Failed to subscribe to symbols {symbols}: {str(e)}", exc_info=True)
                raise SubscriptionError(f"Subscription failed: {str(e)}", symbols=symbols)

    async def unsubscribe(self, symbols: List[str]) -> Dict[str, bool]:
        """取消订阅合约行情

        Args:
            symbols: 合约代码列表

        Returns:
            Dict[str, bool]: 合约代码到取消订阅结果的映射

        Raises:
            SubscriptionError: 取消订阅失败
        """
        # 为什么检查空列表：避免无意义的API调用
        if not symbols:
            logger.warning("No symbols provided for unsubscription")
            return {}

        # 为什么使用锁：防止并发操作导致状态不一致
        async with self.subscription_lock:
            try:
                result: Dict[str, bool] = {}

                # 过滤未订阅的合约 - 为什么先过滤：避免无效的API调用
                subscribed_to_remove = [s for s in symbols if s in self.subscribed_symbols]

                # 未订阅的标记为成功（无需取消）
                for s in symbols:
                    if s not in self.subscribed_symbols:
                        result[s] = True

                if not subscribed_to_remove:
                    logger.info("No symbols to unsubscribe")
                    return result

                # 执行取消订阅
                # api_result = self.api.UnSubscribeMarketData(subscribed_to_remove)
                # if not api_result:
                #     raise SubscriptionError("Failed to unsubscribe from market data")

                # RISK: API成功但本地状态更新失败可能导致状态不一致
                # 为什么先更新状态再触发事件：确保事件处理时状态一致
                for s in subscribed_to_remove:
                    self.subscribed_symbols.discard(s)
                    result[s] = True

                logger.info(f"Unsubscribed from symbols: {subscribed_to_remove}")

                # 触发取消订阅事件
                await self.emit_event(EventType.UNSUBSCRIBED.value, {"symbols": subscribed_to_remove})

                return result

            except Exception as e:
                # RISK: 取消订阅失败可能导致状态不一致
                logger.error(f"Failed to unsubscribe from symbols {symbols}: {str(e)}")
                raise SubscriptionError(f"Unsubscription failed: {str(e)}")

    def _clean_tick_data(self, ctp_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """清洗CTP格式的Tick数据

        Args:
            ctp_data: 原始CTP数据

        Returns:
            Dict: 清洗后的数据，如果数据无效则返回None
        """
        try:
            # 为什么检查基本字段：确保数据完整性
            # 检查基本字段
            required_fields = ["InstrumentID", "ExchangeID", "LastPrice", "Volume"]
            for field in required_fields:
                if field not in ctp_data or ctp_data[field] is None:
                    logger.debug(f"Missing required field: {field}")
                    return None

            # 价格验证 - 为什么检查价格：防止异常价格影响交易决策
            last_price = float(ctp_data.get("LastPrice", 0))
            # CTP 使用 DBL_MAX 表示无效价格
            if last_price <= 0 or last_price >= CTP_INVALID_PRICE:
                logger.debug(f"Invalid last price: {last_price}")
                return None

            # 成交量验证 - 为什么检查成交量：防止异常成交量影响统计
            volume = int(ctp_data.get("Volume", 0))
            if volume < 0:
                logger.debug(f"Invalid volume: {volume}")
                return None

            # 时间戳处理 - 为什么检查时间戳：确保数据时效性
            update_time = ctp_data.get("UpdateTime", "")
            trading_day = ctp_data.get("TradingDay", "")

            if not update_time or not trading_day:
                logger.debug("Missing timestamp information")
                return None

            # 解析CTP时间戳
            tick_datetime = self._parse_ctp_datetime(
                trading_day,
                update_time,
                ctp_data.get("UpdateMillisec", 0),
                ctp_data.get("ActionDay")  # 传递实际日期
            )
            if tick_datetime is None:
                logger.debug("Failed to parse CTP datetime")
                return None

            # 数据正常，返回清洗后的数据
            cleaned = ctp_data.copy()
            cleaned["datetime"] = tick_datetime
            cleaned["local_datetime"] = datetime.now()

            return cleaned

        except Exception as e:
            # RISK: 数据清洗异常可能导致大量数据丢失
            logger.error(f"Error cleaning tick data: {str(e)}")
            return None

    def _parse_ctp_datetime(
        self,
        trading_day: str,
        update_time: str,
        update_millisec: int = 0,
        action_day: Optional[str] = None
    ) -> Optional[datetime]:
        """解析CTP时间戳

        CTP的时间戳处理比较复杂：
        - TradingDay: 交易日（非自然日，周五夜盘的交易日是下周一）
        - ActionDay: 实际发生日期（自然日）
        - UpdateTime: 更新时间 HH:MM:SS

        夜盘时间特殊处理：
        - 21:00-23:59 属于当天夜盘
        - 00:00-02:30 属于前一天夜盘（跨自然日）

        Args:
            trading_day: 交易日，格式 YYYYMMDD
            update_time: 更新时间，格式 HH:MM:SS
            update_millisec: 毫秒数
            action_day: 实际日期，格式 YYYYMMDD（可选）

        Returns:
            datetime: 解析后的时间戳，解析失败返回None
        """
        try:
            # 优先使用 ActionDay（实际日期），否则使用 TradingDay
            date_str = action_day if action_day else trading_day

            # 构造完整时间戳
            datetime_str = f"{date_str} {update_time}"
            dt = datetime.strptime(datetime_str, "%Y%m%d %H:%M:%S")

            # 添加毫秒
            if 0 < update_millisec < 1000:
                dt = dt.replace(microsecond=update_millisec * 1000)

            return dt
        except ValueError as e:
            logger.debug(f"Failed to parse CTP datetime: {e}")
            return None

    def _convert_to_tick_data(self, ctp_data: Dict[str, Any]) -> TickData:
        """将CTP数据转换为标准TickData对象

        Args:
            ctp_data: 清洗后的CTP数据

        Returns:
            TickData: 标准化的Tick数据对象
        """
        # 处理买卖盘价格（CTP使用DBL_MAX表示无效）
        bid_price_1 = ctp_data.get("BidPrice1", 0)
        ask_price_1 = ctp_data.get("AskPrice1", 0)

        # 将无效价格转换为0
        if bid_price_1 >= CTP_INVALID_PRICE:
            bid_price_1 = 0
        if ask_price_1 >= CTP_INVALID_PRICE:
            ask_price_1 = 0

        # 转换CTP字段名到标准字段名
        standard_data = {
            "symbol": ctp_data["InstrumentID"],
            "exchange": ctp_data["ExchangeID"],
            "datetime": ctp_data.get("datetime", datetime.now()),
            "local_datetime": ctp_data.get("local_datetime", datetime.now()),
            "last_price": Decimal(str(ctp_data["LastPrice"])),
            "volume": int(ctp_data.get("Volume", 0)),
            "turnover": Decimal(str(ctp_data.get("Turnover", 0))),
            "open_interest": int(ctp_data.get("OpenInterest", 0)),
            "bid_price_1": Decimal(str(bid_price_1)),
            "ask_price_1": Decimal(str(ask_price_1)),
            "bid_volume_1": int(ctp_data.get("BidVolume1", 0)),
            "ask_volume_1": int(ctp_data.get("AskVolume1", 0)),
        }

        # 使用TickData的from_raw_data方法进行转换
        # 这个方法会处理数据验证和类型转换
        return TickData.from_raw_data(standard_data, source=self.gateway_config.name)

    async def reconnect(self) -> bool:
        """执行重连操作，使用指数退避策略

        使用指数退避算法进行重连，初始等待1秒，每次失败后等待时间翻倍，
        直到达到最大退避时间。当重连失败达到告警阈值时发送告警通知。

        重连流程:
        1. 检查是否允许重连（should_reconnect标志）
        2. 更新状态为RECONNECTING
        3. 尝试连接到服务器
        4. 连接成功则重新订阅之前的合约
        5. 连接失败则等待（指数退避）后重试
        6. 达到告警阈值(10次)时发送钉钉/邮件告警
        7. 达到最大重连次数时停止重连

        指数退避示例:
        - 第1次失败: 等待 1秒
        - 第2次失败: 等待 2秒
        - 第3次失败: 等待 4秒
        - 第4次失败: 等待 8秒
        - ...
        - 第N次失败: 等待 min(2^(N-1), max_backoff_seconds) 秒

        Returns:
            bool: 重连是否成功
                - True: 成功连接并恢复订阅
                - False: 达到最大重连次数或被手动禁用

        Raises:
            无直接抛出异常，所有异常在内部处理

        Example:
            # 自动重连（通常由OnFrontDisconnected回调触发）
            if self.should_reconnect:
                success = await self.reconnect()
                if not success:
                    logger.error("重连失败，请检查网络连接")

            # 手动禁用重连
            gateway.should_reconnect = False
        """
        # ==================== 步骤1: 检查重连开关 ====================
        # REVIEW: 为什么检查should_reconnect？
        # 允许在特殊情况下手动禁用重连（如系统维护、主动断开）
        if not self.should_reconnect:
            logger.info("Reconnection disabled, skipping")
            return False

        # ==================== 步骤2: 初始化重连参数 ====================
        # REVIEW: 为什么使用配置中的值？
        # 允许不同环境使用不同策略（生产环境可能需要更长的退避时间）
        backoff = self.gateway_config.initial_backoff_seconds
        max_attempts = self.gateway_config.max_reconnect_attempts
        # max_attempts=0 表示无限重连
        unlimited = (max_attempts == 0)

        logger.info(
            f"Starting reconnection: backoff={backoff}s, "
            f"max_attempts={'unlimited' if unlimited else max_attempts}"
        )

        # ==================== 步骤3: 重连循环 ====================
        # REVIEW: RISK - 无限重连可能导致资源耗尽
        # 通过告警阈值和最大退避时间来缓解这个问题
        while unlimited or self.reconnect_attempts < max_attempts:
            self.status = GatewayStatus.RECONNECTING
            self.reconnect_attempts += 1
            self._stats['reconnects'] += 1

            # 日志记录当前重连进度
            if unlimited:
                logger.info(f"Reconnection attempt {self.reconnect_attempts} (unlimited mode)")
            else:
                logger.info(
                    f"Reconnection attempt {self.reconnect_attempts}/{max_attempts}"
                )

            # ==================== 步骤4: 告警阈值检查 ====================
            # REVIEW: 如果重连10次失败如何告警？
            # 当达到RECONNECT_ALERT_THRESHOLD(10)次时，发送告警通知
            # 只在首次达到阈值时发送，避免重复告警
            if (self.reconnect_attempts == RECONNECT_ALERT_THRESHOLD
                    and not self._alert_sent):
                self._alert_sent = True
                await self._send_alert(
                    level=AlertLevel.ERROR,
                    message=(
                        f"CTP行情网关重连失败 {RECONNECT_ALERT_THRESHOLD} 次，"
                        f"请检查网络连接和服务器状态。"
                        f"前置地址: {self.gateway_config.ctp.front_addr}"
                    ),
                    alert_id="reconnect_threshold",
                    details={
                        "gateway_name": self.gateway_config.name,
                        "front_addr": self.gateway_config.ctp.front_addr,
                        "reconnect_attempts": self.reconnect_attempts,
                        "threshold": RECONNECT_ALERT_THRESHOLD,
                        "subscribed_symbols": list(self.subscribed_symbols)[:10],
                        "last_tick_time": (
                            self._last_tick_time.isoformat()
                            if self._last_tick_time else None
                        )
                    }
                )
                logger.error(
                    f"ALERT: Reconnection failed {RECONNECT_ALERT_THRESHOLD} times, "
                    f"alert sent to notification channels"
                )

            # ==================== 步骤5: 尝试连接 ====================
            # REVIEW: 为什么使用try-except？
            # 捕获连接异常并继续重试，避免单次失败中断重连流程
            try:
                if await self.connect():
                    # ==================== 步骤6: 连接成功处理 ====================
                    logger.info(
                        f"Reconnection successful after {self.reconnect_attempts} attempts"
                    )

                    # REVIEW: 为什么重新订阅？
                    # 重连后服务器端订阅状态已清空，需要重新订阅
                    # RISK: 重连后服务器端订阅状态已清空，需要重新订阅
                    if self.subscribed_symbols:
                        # 保存需要重新订阅的合约列表
                        symbols_to_resubscribe = list(self.subscribed_symbols)
                        # 清空本地订阅状态，避免subscribe()跳过已订阅的合约
                        self.subscribed_symbols.clear()

                        logger.info(
                            f"Re-subscribing to {len(symbols_to_resubscribe)} symbols"
                        )
                        try:
                            await self.subscribe(symbols_to_resubscribe)
                        except Exception as sub_error:
                            # 订阅失败不影响连接成功的返回
                            logger.error(
                                f"Failed to re-subscribe after reconnect: {sub_error}"
                            )

                    # 重置告警状态，下次断开重连时可以再次告警
                    self._alert_sent = False

                    # 触发重连成功事件
                    await self.emit_event(EventType.CONNECTED.value, {
                        "gateway": self.gateway_config.name,
                        "event": "reconnected",
                        "attempts": self.reconnect_attempts,
                        "timestamp": datetime.now().isoformat()
                    })

                    return True

            except Exception as e:
                # REVIEW: 异常处理策略
                # 记录警告但不抛出，继续下一次重连尝试
                logger.warning(
                    f"Reconnection attempt {self.reconnect_attempts} failed: {str(e)}"
                )

            # ==================== 步骤7: 检查是否达到最大重连次数 ====================
            if not unlimited and self.reconnect_attempts >= max_attempts:
                logger.error(
                    f"Max reconnection attempts ({max_attempts}) reached, giving up"
                )
                self.status = GatewayStatus.ERROR

                # REVIEW: 达到最大重连次数时发送严重告警
                await self._send_alert(
                    level=AlertLevel.CRITICAL,
                    message=(
                        f"CTP行情网关重连失败，已达最大重连次数 {max_attempts}。"
                        f"系统已停止自动重连，请人工介入处理。"
                    ),
                    alert_id="reconnect_max_reached",
                    details={
                        "gateway_name": self.gateway_config.name,
                        "front_addr": self.gateway_config.ctp.front_addr,
                        "max_attempts": max_attempts,
                        "final_status": self.status.value
                    }
                )
                break

            # ==================== 步骤8: 指数退避等待 ====================
            # REVIEW: RISK - 长时间等待可能阻塞其他操作
            # 使用asyncio.sleep不会阻塞事件循环
            logger.info(f"Waiting {backoff} seconds before next attempt")
            await asyncio.sleep(backoff)

            # REVIEW: 为什么使用指数退避？
            # 1. 避免频繁重连加重服务器负担
            # 2. 给网络恢复留出时间
            # 3. 符合行业最佳实践（如AWS SDK、gRPC等都采用此策略）
            # 退避公式: backoff = min(backoff * 2, max_backoff)
            backoff = min(
                backoff * 2,
                min(self.gateway_config.max_backoff_seconds, MAX_RECONNECT_DELAY_SECONDS)
            )

        # ==================== 重连失败返回 ====================
        logger.error(
            f"Reconnection failed after {self.reconnect_attempts} attempts"
        )
        return False

    async def disconnect(self) -> None:
        """断开与CTP服务器的连接

        Raises:
            ConnectionError: 断开连接失败
        """
        try:
            self.should_reconnect = False

            # 取消心跳任务
            if self._heartbeat_task and not self._heartbeat_task.done():
                self._heartbeat_task.cancel()
                try:
                    await self._heartbeat_task
                except asyncio.CancelledError:
                    pass
                self._heartbeat_task = None

            # 清空数据队列
            while not self._data_queue.empty():
                try:
                    self._data_queue.get_nowait()
                except asyncio.QueueEmpty:
                    break

            if self.api:
                # self.api.Release()
                self.api = None

            self.status = GatewayStatus.DISCONNECTED
            self.connected = False
            self.logged_in = False
            logger.info("Disconnected from CTP server")

        except Exception as e:
            logger.error(f"Error disconnecting from CTP server: {str(e)}")
            raise ConnectionError(f"Disconnect failed: {str(e)}")

    def is_healthy(self) -> bool:
        """检查网关是否健康

        Returns:
            bool: 网关是否处于健康状态
        """
        # 基本连接状态检查
        if self.status != GatewayStatus.CONNECTED:
            return False

        if not self.connected or not self.logged_in:
            return False

        # 检查最近是否有数据（如果有订阅的话）
        if self.subscribed_symbols and self._last_tick_time:
            idle_seconds = (datetime.now() - self._last_tick_time).total_seconds()
            # 超过5分钟没有数据认为不健康
            if idle_seconds > 300:
                return False

        return True

    def get_stats(self) -> Dict[str, Any]:
        """获取网关统计信息

        Returns:
            Dict[str, Any]: 统计信息字典
        """
        return {
            **self._stats,
            'status': self.status.value,
            'connected': self.connected,
            'logged_in': self.logged_in,
            'subscribed_count': len(self.subscribed_symbols),
            'queue_size': self._data_queue.qsize(),
            'last_tick_time': self._last_tick_time.isoformat() if self._last_tick_time else None,
            'is_healthy': self.is_healthy()
        }

    def reset_stats(self) -> None:
        """重置统计信息"""
        self._stats = {
            'ticks_received': 0,
            'ticks_processed': 0,
            'ticks_filtered': 0,
            'errors': 0,
            'reconnects': 0
        }
        logger.info("Gateway statistics reset")

    async def __aenter__(self) -> 'CtpMarketGateway':
        """异步上下文管理器入口

        Returns:
            CtpMarketGateway: 网关实例
        """
        await self.connect()
        return self

    async def __aexit__(self, _exc_type: Any, _exc_val: Any, _exc_tb: Any) -> None:
        """异步上下文管理器出口

        Args:
            _exc_type: 异常类型（未使用）
            _exc_val: 异常值（未使用）
            _exc_tb: 异常追踪信息（未使用）
        """
        await self.disconnect()

    def __repr__(self) -> str:
        """返回网关的字符串表示"""
        return (f"CtpMarketGateway(name={self.gateway_config.name}, "
                f"status={self.status.value}, "
                f"subscribed_symbols={len(self.subscribed_symbols)})")

    # CTP API回调方法（实际使用时需要实现）
    def OnFrontConnected(self) -> None:
        """CTP前置连接成功回调"""
        logger.info("CTP front connected")
        self.connected = True

    def OnFrontDisconnected(self, nReason: int) -> None:
        """CTP前置断开连接回调

        Args:
            nReason: 断开原因代码
        """
        reason_desc = CTP_DISCONNECT_REASONS.get(nReason, f"未知原因({nReason})")
        logger.warning(f"CTP front disconnected: {reason_desc}")
        self.connected = False
        self.logged_in = False
        self.status = GatewayStatus.DISCONNECTED

        # 如果启用自动重连，则触发重连
        if self.should_reconnect:
            asyncio.create_task(self.reconnect())

    def OnRspUserLogin(self, _pRspUserLogin: Any, pRspInfo: Any, _nRequestID: int, _bIsLast: bool) -> None:
        """CTP登录响应回调

        Args:
            _pRspUserLogin: 登录响应结构（未使用）
            pRspInfo: 响应信息结构
            _nRequestID: 请求ID（未使用）
            _bIsLast: 是否为最后一个响应（未使用）
        """
        if pRspInfo and pRspInfo.ErrorID != 0:
            logger.error(f"CTP login failed: {pRspInfo.ErrorMsg}")
            self.status = GatewayStatus.ERROR
            return
            
        logger.info("CTP login successful")
        self.logged_in = True
        self.status = GatewayStatus.CONNECTED

    def OnRspSubMarketData(self, pSpecificInstrument: Any, pRspInfo: Any, _nRequestID: int, _bIsLast: bool) -> None:
        """CTP订阅行情响应回调

        Args:
            pSpecificInstrument: 合约信息结构
            pRspInfo: 响应信息结构
            _nRequestID: 请求ID（未使用）
            _bIsLast: 是否为最后一个响应（未使用）
        """
        if pRspInfo and pRspInfo.ErrorID != 0:
            logger.error(f"CTP subscribe failed: {pRspInfo.ErrorMsg}")
            return
            
        symbol = pSpecificInstrument.InstrumentID if pSpecificInstrument else "unknown"
        logger.info(f"CTP subscribe successful: {symbol}")

    def OnRspUnSubMarketData(self, pSpecificInstrument: Any, pRspInfo: Any, _nRequestID: int, _bIsLast: bool) -> None:
        """CTP取消订阅行情响应回调

        Args:
            pSpecificInstrument: 合约信息结构
            pRspInfo: 响应信息结构
            _nRequestID: 请求ID（未使用）
            _bIsLast: 是否为最后一个响应（未使用）
        """
        if pRspInfo and pRspInfo.ErrorID != 0:
            logger.error(f"CTP unsubscribe failed: {pRspInfo.ErrorMsg}")
            return
            
        symbol = pSpecificInstrument.InstrumentID if pSpecificInstrument else "unknown"
        logger.info(f"CTP unsubscribe successful: {symbol}")

    def OnRtnDepthMarketData(self, pDepthMarketData: Any) -> None:
        """CTP行情数据回调

        Args:
            pDepthMarketData: 深度行情数据结构
        """
        try:
            # 为什么使用try-except：防止CTP回调异常导致连接中断
            # 将CTP结构转换为字典
            if not pDepthMarketData:
                return

            # 提取CTP数据字段
            ctp_data = {
                # 合约信息
                "InstrumentID": getattr(pDepthMarketData, "InstrumentID", ""),
                "ExchangeID": getattr(pDepthMarketData, "ExchangeID", ""),
                # 最新价和成交信息
                "LastPrice": getattr(pDepthMarketData, "LastPrice", 0),
                "Volume": getattr(pDepthMarketData, "Volume", 0),
                "Turnover": getattr(pDepthMarketData, "Turnover", 0),
                "OpenInterest": getattr(pDepthMarketData, "OpenInterest", 0),
                # 买卖盘
                "BidPrice1": getattr(pDepthMarketData, "BidPrice1", 0),
                "AskPrice1": getattr(pDepthMarketData, "AskPrice1", 0),
                "BidVolume1": getattr(pDepthMarketData, "BidVolume1", 0),
                "AskVolume1": getattr(pDepthMarketData, "AskVolume1", 0),
                # 时间信息
                "UpdateTime": getattr(pDepthMarketData, "UpdateTime", ""),
                "TradingDay": getattr(pDepthMarketData, "TradingDay", ""),
                "ActionDay": getattr(pDepthMarketData, "ActionDay", ""),
                "UpdateMillisec": getattr(pDepthMarketData, "UpdateMillisec", 0),
                # 涨跌停价格
                "UpperLimitPrice": getattr(pDepthMarketData, "UpperLimitPrice", 0),
                "LowerLimitPrice": getattr(pDepthMarketData, "LowerLimitPrice", 0),
                # 开高低收
                "OpenPrice": getattr(pDepthMarketData, "OpenPrice", 0),
                "HighestPrice": getattr(pDepthMarketData, "HighestPrice", 0),
                "LowestPrice": getattr(pDepthMarketData, "LowestPrice", 0),
                "PreClosePrice": getattr(pDepthMarketData, "PreClosePrice", 0),
                "PreSettlementPrice": getattr(pDepthMarketData, "PreSettlementPrice", 0),
            }

            # RISK: 同步回调中创建异步任务可能导致任务堆积
            # 为什么使用create_task：避免阻塞CTP回调线程
            asyncio.create_task(self.on_tick(ctp_data))

        except Exception as e:
            # RISK: 回调中的异常可能导致CTP连接中断
            # 为什么记录错误但不抛出：避免影响CTP API正常运行
            self._stats['errors'] += 1
            logger.error(f"Error processing CTP market data: {str(e)}")


__all__ = ['CtpMarketGateway']