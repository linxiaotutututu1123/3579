     1→"""Simulation/Replay gate for machine-readable reporting.
     2→
     3→Provides simulation and replay result reporting in JSON format for
     4→Claude automated loop integration.
     5→
     6→Military-grade v3.0 enhancements:
     7→- schema_version: integer, must be >= 3
     8→- rule_id: scenario identifier (e.g., UNIV.DOMINANT.BASIC)
     9→- component: module under test
    10→- evidence: state snapshot for debugging
    11→- check_mode: mandatory for all replay/sim
    12→"""
    13→
    14→from __future__ import annotations
    15→
    16→import json
    17→import logging
    18→from dataclasses import asdict, dataclass, field
    19→from datetime import UTC, datetime
    20→from enum import Enum
    21→from pathlib import Path
    22→from typing import Any
    23→
    24→
    25→logger = logging.getLogger(__name__)
    26→
    27→
    28→class SimStatus(str, Enum):
    29→    """Simulation/Replay status."""
    30→
    31→    PASS = "PASS"
    32→    FAIL = "FAIL"
    33→
    34→
    35→@dataclass(frozen=True)
    36→class ScenarioFailure:
    37→    """Single scenario failure detail (military-grade v3.0).
    38→
    39→    All fields are required for Claude to auto-fix (文档 C.2):
    40→    - scenario: 场景名称
    41→    - rule_id: unique scenario identifier
    42→    - component: module under test
    43→    - event_id: 关联事件 ID（或 tick）
    44→    - expected/actual: comparison values
    45→    - error: human-readable description
    46→    - evidence: state snapshot for debugging (dict，哪怕是空也必须存在)
    47→    """
    48→
    49→    scenario: str
    50→    rule_id: str  # e.g., "UNIV.DOMINANT.BASIC"
    51→    component: str  # e.g., "universe_selector"
    52→    tick: int  # 也作为 event_id 使用
    53→    expected: dict[str, Any]
    54→    actual: dict[str, Any]
    55→    error: str
    56→    evidence: dict[str, Any] = field(default_factory=dict)
    57→    event_id: str = ""  # 可选：关联到 events.jsonl 中的 event_id
    58→
    59→    def to_dict(self) -> dict[str, Any]:
    60→        """Convert to dictionary (Military-Grade v3.0)."""
    61→        return {
    62→            "scenario": self.scenario,
    63→            "rule_id": self.rule_id,
    64→            "component": self.component,
    65→            "event_id": self.event_id or str(self.tick),  # 如果没有 event_id 用 tick
    66→            "tick": self.tick,
    67→            "expected": self.expected,
    68→            "actual": self.actual,
    69→            "error": self.error,
    70→            "evidence": self.evidence,  # 必须存在，哪怕是空 dict
    71→        }
    72→
    73→
    74→@dataclass
    75→class SimMetrics:
    76→    """Simulation metrics summary."""
    77→
    78→    total_ticks: int = 0
    79→    avg_tick_duration_ms: float = 0.0
    80→    max_drawdown_pct: float = 0.0
    81→    orders_placed: int = 0
    82→    orders_rejected: int = 0
    83→    orders_filled: int = 0
    84→    pnl_total: float = 0.0
    85→
    86→    def to_dict(self) -> dict[str, Any]:
    87→        """Convert to dictionary."""
    88→        return asdict(self)
    89→
    90→
    91→# =============================================================================
    92→# 辅助函数：生成 run_id / exec_id
    93→# =============================================================================
    94→
    95→
    96→def _generate_run_id() -> str:
    97→    """Generate a unique run_id (UUID)."""
    98→    import uuid
    99→
   100→    return str(uuid.uuid4())
   101→
   102→
   103→def _generate_exec_id() -> str:
   104→    """Generate exec_id from git commit + timestamp."""
   105→    import subprocess
   106→
   107→    try:
   108→        result = subprocess.run(
   109→            ["git", "rev-parse", "HEAD"],
   110→            capture_output=True,
   111→            text=True,
   112→            check=False,
   113→        )
   114→        commit = result.stdout.strip()[:8] if result.returncode == 0 else "unknown"
   115→    except Exception:
   116→        commit = "unknown"
   117→    ts = datetime.now(UTC).strftime("%Y%m%d%H%M%S")
   118→    return f"{commit}_{ts}"
   119→
   120→
   121→def _compute_context_sha(context_path: Path) -> str:
   122→    """Compute SHA256 of context.md for audit."""
   123→    import hashlib
   124→
   125→    if not context_path.exists():
   126→        return ""
   127→    with open(context_path, "rb") as f:
   128→        return hashlib.sha256(f.read()).hexdigest()
   129→
   130→
   131→# 军规级固定路径约定 (D.1) - 按 type 严格分目录
   132→FIXED_PATHS = {
   133→    # Replay 产物（独立目录）
   134→    "replay_report": Path("artifacts/replay/report.json"),
   135→    "replay_events_jsonl": Path("artifacts/replay/events.jsonl"),
   136→    # Sim 产物（独立目录）
   137→    "sim_report": Path("artifacts/sim/report.json"),
   138→    "sim_events_jsonl": Path("artifacts/sim/events.jsonl"),
   139→    # 共享产物
   140→    "context": Path("artifacts/context/context.md"),
   141→}
   142→
   143→
   144→def get_paths_for_type(report_type: str) -> dict[str, Path]:
   145→    """根据 type 返回正确的产物路径（军规级）."""
   146→    if report_type == "replay":
   147→        return {
   148→            "report": FIXED_PATHS["replay_report"],
   149→            "events_jsonl": FIXED_PATHS["replay_events_jsonl"],
   150→            "context": FIXED_PATHS["context"],
   151→        }
   152→    return {
   153→        "report": FIXED_PATHS["sim_report"],
   154→        "events_jsonl": FIXED_PATHS["sim_events_jsonl"],
   155→        "context": FIXED_PATHS["context"],
   156→    }
   157→
   158→
   159→@dataclass
   160→class SimReport:
   161→    """Full simulation/replay report (military-grade v3.0).
   162→
   163→    Military-grade required fields:
   164→    - schema_version: integer, must be >= 3
   165→    - type: "replay" or "sim"
   166→    - check_mode: must be True
   167→    - run_id: UUID for traceability
   168→    - exec_id: commit_sha + timestamp
   169→    - artifacts: paths to generated files
   170→    - failures with rule_id/component/evidence
   171→    """
   172→
   173→    type: str  # "replay" or "sim"
   174→    scenarios_total: int = 0
   175→    scenarios_passed: int = 0
   176→    scenarios_failed: int = 0
   177→    failures: list[ScenarioFailure] = field(default_factory=list)
   178→    metrics: SimMetrics = field(default_factory=SimMetrics)
   179→    schema_version: int = 3
   180→    check_mode: bool = False
   181→    timestamp: str = ""
   182→    run_id: str = ""
   183→    exec_id: str = ""
   184→    context_manifest_sha: str = ""
   185→
   186→    def __post_init__(self) -> None:
   187→        if not self.timestamp:
   188→            self.timestamp = datetime.now(UTC).isoformat()
   189→        if not self.run_id:
   190→            self.run_id = _generate_run_id()
   191→        if not self.exec_id:
   192→            self.exec_id = _generate_exec_id()
   193→        # Compute context SHA if available
   194→        context_path = FIXED_PATHS["context"]
   195→        if not self.context_manifest_sha and context_path.exists():
   196→            self.context_manifest_sha = _compute_context_sha(context_path)
   197→
   198→    @property
   199→    def overall(self) -> SimStatus:
   200→        """Overall status."""
   201→        return SimStatus.PASS if self.scenarios_failed == 0 else SimStatus.FAIL
   202→
   203→    @property
   204→    def passed(self) -> bool:
   205→        """Check if all scenarios passed."""
   206→        return self.scenarios_failed == 0
   207→
   208→    @property
   209→    def exit_code(self) -> int:
   210→        """Get exit code based on type and status."""
   211→        if self.passed:
   212→            return SimExitCode.SUCCESS
   213→        return SimExitCode.REPLAY_FAIL if self.type == "replay" else SimExitCode.SIM_FAIL
   214→
   215→    def add_pass(self, scenario: str, rule_id: str = "", component: str = "") -> None:
   216→        """Record a passed scenario."""
   217→        self.scenarios_total += 1
   218→        self.scenarios_passed += 1
   219→        logger.info("PASS: %s [%s]", scenario, rule_id or "no_rule_id")
   220→
   221→    def add_failure(
   222→        self,
   223→        scenario: str,
   224→        tick: int,
   225→        expected: dict[str, Any],
   226→        actual: dict[str, Any],
   227→        error: str,
   228→        *,
   229→        rule_id: str = "",
   230→        component: str = "",
   231→        evidence: dict[str, Any] | None = None,
   232→    ) -> None:
   233→        """Record a failed scenario (military-grade v3.0)."""
   234→        self.scenarios_total += 1
   235→        self.scenarios_failed += 1
   236→        self.failures.append(
   237→            ScenarioFailure(
   238→                scenario=scenario,
   239→                rule_id=rule_id or f"UNKNOWN.{scenario.upper().replace(' ', '_')}",
   240→                component=component or "unknown",
   241→                tick=tick,
   242→                expected=expected,
   243→                actual=actual,
   244→                error=error,
   245→                evidence=evidence or {},
   246→            )
   247→        )
   248→        logger.error("FAIL: %s [%s] at tick %d: %s", scenario, rule_id, tick, error)
   249→
   250→    def to_dict(self) -> dict[str, Any]:
   251→        """Convert to dictionary for JSON serialization (Military-Grade v3.0)."""
   252→        # 根据 type 获取正确的产物路径
   253→        paths = get_paths_for_type(self.type)
   254→
   255→        return {
   256→            # 强制顶层字段（缺一不可）
   257→            "schema_version": self.schema_version,
   258→            "type": self.type,
   259→            "overall": self.overall.value,
   260→            "exit_code": self.exit_code,
   261→            "check_mode": self.check_mode,
   262→            "timestamp": self.timestamp,
   263→            "run_id": self.run_id,
   264→            "exec_id": self.exec_id,
   265→            # 军规级：artifacts 路径必须与 type 匹配
   266→            "artifacts": {
   267→                "report_path": str(paths["report"]),
   268→                "events_jsonl_path": str(paths["events_jsonl"]),
   269→                "context_path": str(paths["context"]),
   270→            },
   271→            "context_manifest_sha": self.context_manifest_sha,
   272→            # 场景统计（单一字段，无重复）
   273→            "scenarios": {
   274→                "total": self.scenarios_total,
   275→                "passed": self.scenarios_passed,
   276→                "failed": self.scenarios_failed,
   277→                "skipped": 0,
   278→            },
   279→            # 军规级扩展字段
   280→            "required_scenarios_checked": False,  # 待 validate_policy 填充
   281→            "required_scenarios_profile": "v2",  # 默认 v2
   282→            # 详情
   283→            "failures": [f.to_dict() for f in self.failures],
   284→            "metrics": self.metrics.to_dict(),
   285→        }
   286→
   287→    def to_json(self, indent: int = 2) -> str:
   288→        """Convert to JSON string."""
   289→        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)
   290→
   291→    def summary(self) -> str:
   292→        """Generate summary string."""
   293→        status = self.overall.value
   294→        return (
   295→            f"Sim Gate [{self.type}]: {status} "
   296→            f"({self.scenarios_passed}/{self.scenarios_total} passed)"
   297→        )
   298→
   299→
   300→class SimGate:
   301→    """
   302→    Simulation/Replay gate for automated validation (military-grade v3.0).
   303→
   304→    Collects scenario results and generates machine-readable reports
   305→    with rule_id, component, and evidence for Claude auto-fix.
   306→    """
   307→
   308→    def __init__(self, sim_type: str = "replay", check_mode: bool = False) -> None:
   309→        """
   310→        Initialize simulation gate.
   311→
   312→        Args:
   313→            sim_type: Type of simulation ("replay" or "sim")
   314→            check_mode: Whether CHECK_MODE is enabled (must be True for production)
   315→        """
   316→        self._report = SimReport(type=sim_type, check_mode=check_mode)
   317→
   318→    @property
   319→    def report(self) -> SimReport:
   320→        """Get current report."""
   321→        return self._report
   322→
   323→    def set_check_mode(self, enabled: bool) -> None:
   324→        """Set CHECK_MODE flag."""
   325→        self._report.check_mode = enabled
   326→
   327→    def record_pass(
   328→        self,
   329→        scenario: str,
   330→        *,
   331→        rule_id: str = "",
   332→        component: str = "",
   333→    ) -> None:
   334→        """Record a passed scenario."""
   335→        self._report.add_pass(scenario, rule_id=rule_id, component=component)
   336→
   337→    def record_failure(
   338→        self,
   339→        scenario: str,
   340→        tick: int,
   341→        expected: dict[str, Any],
   342→        actual: dict[str, Any],
   343→        error: str,
   344→        *,
   345→        rule_id: str = "",
   346→        component: str = "",
   347→        evidence: dict[str, Any] | None = None,
   348→    ) -> None:
   349→        """Record a failed scenario (military-grade v3.0)."""
   350→        self._report.add_failure(
   351→            scenario,
   352→            tick,
   353→            expected,
   354→            actual,
   355→            error,
   356→            rule_id=rule_id,
   357→            component=component,
   358→            evidence=evidence,
   359→        )
   360→
   361→    def set_metrics(
   362→        self,
   363→        *,
   364→        total_ticks: int = 0,
   365→        avg_tick_duration_ms: float = 0.0,
   366→        max_drawdown_pct: float = 0.0,
   367→        orders_placed: int = 0,
   368→        orders_rejected: int = 0,
   369→        orders_filled: int = 0,
   370→        pnl_total: float = 0.0,
   371→    ) -> None:
   372→        """Set simulation metrics."""
   373→        self._report.metrics = SimMetrics(
   374→            total_ticks=total_ticks,
   375→            avg_tick_duration_ms=avg_tick_duration_ms,
   376→            max_drawdown_pct=max_drawdown_pct,
   377→            orders_placed=orders_placed,
   378→            orders_rejected=orders_rejected,
   379→            orders_filled=orders_filled,
   380→            pnl_total=pnl_total,
   381→        )
   382→
   383→    def generate_report(self) -> SimReport:
   384→        """Generate final report."""
   385→        return self._report
   386→
   387→    def save_report(self, path: str | Path) -> None:
   388→        """
   389→        Save report to JSON file.
   390→
   391→        Args:
   392→            path: Output file path (typically artifacts/sim/report.json)
   393→        """
   394→        path = Path(path)
   395→        path.parent.mkdir(parents=True, exist_ok=True)
   396→        path.write_text(self._report.to_json(), encoding="utf-8")
   397→        logger.info("Sim report saved to %s", path)
   398→
   399→
   400→# =============================================================================
   401→# 退出码（军规级）
   402→# =============================================================================
   403→class SimExitCode:
   404→    """Exit codes for simulation/replay (military-grade).
   405→
   406→    Exit codes:
   407→        0 = All scenarios passed
   408→        8 = Replay failed
   409→        9 = Sim failed
   410→        12 = Policy violation (military-grade enforcement)
   411→    """
   412→
   413→    SUCCESS = 0
   414→    REPLAY_FAIL = 8
   415→    SIM_FAIL = 9
   416→    POLICY_VIOLATION = 12
   417→
   418→
   419→def get_sim_exit_code(report: SimReport) -> int:
   420→    """Determine exit code based on sim report."""
   421→    if report.passed:
   422→        return SimExitCode.SUCCESS
   423→
   424→    if report.type == "replay":
   425→        return SimExitCode.REPLAY_FAIL
   426→    return SimExitCode.SIM_FAIL
   427→
   428→
   429→# =============================================================================
   430→# V2 Required Scenarios 加载与校验（军规级）
   431→# =============================================================================
   432→
   433→
   434→def load_required_scenarios(  # pragma: no cover
   435→    yaml_path: str | Path = "V2_REQUIRED_SCENARIOS.yml",
   436→) -> dict[str, Any]:
   437→    """
   438→    Load V2 required scenarios from YAML.
   439→
   440→    Args:
   441→        yaml_path: Path to V2_REQUIRED_SCENARIOS.yml
   442→
   443→    Returns:
   444→        Parsed YAML content
   445→    """
   446→    import yaml
   447→
   448→    path = Path(yaml_path)
   449→    if not path.exists():
   450→        logger.warning("V2_REQUIRED_SCENARIOS.yml not found: %s", path)
   451→        return {}
   452→
   453→    with open(path, encoding="utf-8") as f:
   454→        return yaml.safe_load(f) or {}
   455→
   456→
   457→def validate_scenario_coverage(  # pragma: no cover
   458→    report: SimReport,
   459→    required_scenarios: dict[str, Any],
   460→) -> list[dict[str, Any]]:
   461→    """
   462→    Validate that all required scenarios were executed.
   463→
   464→    Args:
   465→        report: SimReport with executed scenarios
   466→        required_scenarios: Loaded V2_REQUIRED_SCENARIOS.yml
   467→
   468→    Returns:
   469→        List of missing/skipped scenario violations
   470→    """
   471→    violations: list[dict[str, Any]] = []
   472→
   473→    if not required_scenarios:
   474→        return violations
   475→
   476→    # Collect all required rule_ids
   477→    required_rule_ids: set[str] = set()
   478→    phases = required_scenarios.get("phases", {})
   479→    for phase_data in phases.values():
   480→        if not isinstance(phase_data, dict):
   481→            continue
   482→        scenarios = phase_data.get("scenarios", [])
   483→        for scenario in scenarios:
   484→            if isinstance(scenario, dict) and scenario.get("required", True):
   485→                rule_id = scenario.get("rule_id", "")
   486→                if rule_id:
   487→                    required_rule_ids.add(rule_id)
   488→
   489→    # Collect executed rule_ids
   490→    executed_rule_ids: set[str] = set()
   491→    for failure in report.failures:
   492→        if failure.rule_id:
   493→            executed_rule_ids.add(failure.rule_id)
   494→
   495→    # TODO: Also track passed scenarios (need to store rule_ids in passes)
   496→    # For now, we only check if failures have proper rule_ids
   497→
   498→    # Check for missing rule_ids in failures
   499→    for failure in report.failures:
   500→        if not failure.rule_id or failure.rule_id.startswith("UNKNOWN."):
   501→            violations.append(
   502→                {
   503→                    "type": "MISSING_RULE_ID",
   504→                    "scenario": failure.scenario,
   505→                    "message": "Failure missing proper rule_id",
   506→                }
   507→            )
   508→
   509→    return violations
   510→
   511→
   512→# =============================================================================
   513→# 便捷函数
   514→# =============================================================================
   515→
   516→
   517→def run_replay_with_report(  # pragma: no cover
   518→    scenarios: list[dict[str, Any]],
   519→    output_path: str | None = None,
   520→) -> SimReport:
   521→    """
   522→    Run replay scenarios and generate report.
   523→
   524→    This is a convenience function that runs all scenarios and
   525→    generates a machine-readable report.
   526→
   527→    Args:
   528→        scenarios: List of scenario configs to run
   529→        output_path: Output path for JSON report (defaults to correct path for type)
   530→
   531→    Returns:
   532→        SimReport with all results
   533→    """
   534→    gate = SimGate(sim_type="replay")
   535→
   536→    # 军规级：默认使用正确的 type 路径
   537→    if output_path is None:
   538→        output_path = str(FIXED_PATHS["replay_report"])
   539→
   540→    # TODO: Integrate with actual replay runner
   541→    # For now, this is a placeholder that should be connected to
   542→    # src/replay/runner.py
   543→
   544→    logger.info("Running %d replay scenarios...", len(scenarios))
   545→
   546→    # Placeholder: run each scenario
   547→    for scenario in scenarios:
   548→        name = scenario.get("name", "unnamed")
   549→        # In real implementation, call run_replay_tick() and check assertions
   550→        # For now, just mark as pass
   551→        gate.record_pass(name)
   552→
   553→    gate.save_report(output_path)
   554→    return gate.report
   555→
   556→
   557→def log_sim_report(report: SimReport) -> None:  # pragma: no cover
   558→    """Log simulation report."""
   559→    logger.info(report.summary())
   560→
   561→    if report.failures:
   562→        logger.error("Failures:")
   563→        for failure in report.failures:
   564→            logger.error(
   565→                "  %s @ tick %d: %s",
   566→                failure.scenario,
   567→                failure.tick,
   568→                failure.error,
   569→            )
   570→
   571→    logger.info("Metrics:")
   572→    logger.info("  Total ticks: %d", report.metrics.total_ticks)
   573→    logger.info("  Avg tick duration: %.2f ms", report.metrics.avg_tick_duration_ms)
   574→    logger.info("  Max drawdown: %.2f%%", report.metrics.max_drawdown_pct)
   575→    logger.info(
   576→        "  Orders: %d placed, %d rejected, %d filled",
   577→        report.metrics.orders_placed,
   578→        report.metrics.orders_rejected,
   579→        report.metrics.orders_filled,
   580→    )
   581→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
