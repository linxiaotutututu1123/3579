     1→"""
     2→ThrottleGate - 节流控制.
     3→
     4→V3PRO+ Platform Component - Phase 2
     5→V2 SPEC: 5.9.3
     6→V2 Scenario: EXEC.PROTECTION.THROTTLE
     7→
     8→军规级要求:
     9→- 限制每分钟订单数
    10→- 限制订单最小间隔
    11→- 防止过度交易
    12→"""
    13→
    14→from __future__ import annotations
    15→
    16→import time
    17→from collections import deque
    18→from dataclasses import dataclass
    19→from enum import Enum
    20→from typing import Any
    21→
    22→
    23→class ThrottleCheckResult(Enum):
    24→    """节流检查结果."""
    25→
    26→    PASS = "PASS"  # 通过
    27→    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED"  # 频率限制
    28→    MIN_INTERVAL_VIOLATED = "MIN_INTERVAL_VIOLATED"  # 最小间隔违规
    29→
    30→
    31→@dataclass
    32→class ThrottleConfig:
    33→    """节流配置.
    34→
    35→    Attributes:
    36→        max_orders_per_minute: 每分钟最大订单数
    37→        min_interval_s: 最小订单间隔（秒）
    38→        window_s: 统计窗口（秒）
    39→    """
    40→
    41→    max_orders_per_minute: int = 60
    42→    min_interval_s: float = 1.0
    43→    window_s: float = 60.0
    44→
    45→
    46→@dataclass
    47→class ThrottleCheckOutput:
    48→    """节流检查输出.
    49→
    50→    Attributes:
    51→        result: 检查结果
    52→        orders_in_window: 窗口内订单数
    53→        time_since_last: 距上次订单时间（秒）
    54→        wait_time_s: 需要等待的时间（秒）
    55→        message: 详细信息
    56→    """
    57→
    58→    result: ThrottleCheckResult
    59→    orders_in_window: int = 0
    60→    time_since_last: float = 0.0
    61→    wait_time_s: float = 0.0
    62→    message: str = ""
    63→
    64→    def passed(self) -> bool:
    65→        """是否通过."""
    66→        return self.result == ThrottleCheckResult.PASS
    67→
    68→    def to_dict(self) -> dict[str, Any]:
    69→        """转换为字典."""
    70→        return {
    71→            "result": self.result.value,
    72→            "orders_in_window": self.orders_in_window,
    73→            "time_since_last": self.time_since_last,
    74→            "wait_time_s": self.wait_time_s,
    75→            "message": self.message,
    76→        }
    77→
    78→
    79→class ThrottleGate:
    80→    """节流门控.
    81→
    82→    V2 Scenario: EXEC.PROTECTION.THROTTLE
    83→
    84→    检查:
    85→    - 每分钟订单数不超过限制
    86→    - 订单间隔不小于最小值
    87→    """
    88→
    89→    def __init__(self, config: ThrottleConfig | None = None) -> None:
    90→        """初始化节流门控.
    91→
    92→        Args:
    93→            config: 节流配置
    94→        """
    95→        self._config = config or ThrottleConfig()
    96→        self._order_times: deque[float] = deque()
    97→        self._last_order_time: float = 0.0
    98→        self._check_count = 0
    99→        self._reject_count = 0
   100→
   101→    @property
   102→    def config(self) -> ThrottleConfig:
   103→        """配置."""
   104→        return self._config
   105→
   106→    @property
   107→    def check_count(self) -> int:
   108→        """检查次数."""
   109→        return self._check_count
   110→
   111→    @property
   112→    def reject_count(self) -> int:
   113→        """拒绝次数."""
   114→        return self._reject_count
   115→
   116→    def check(self, now: float | None = None) -> ThrottleCheckOutput:
   117→        """检查节流.
   118→
   119→        V2 Scenario: EXEC.PROTECTION.THROTTLE
   120→
   121→        Args:
   122→            now: 当前时间戳
   123→
   124→        Returns:
   125→            检查输出
   126→        """
   127→        if now is None:
   128→            now = time.time()
   129→
   130→        self._check_count += 1
   131→
   132→        # 清理过期记录
   133→        self._cleanup(now)
   134→
   135→        # 计算窗口内订单数
   136→        orders_in_window = len(self._order_times)
   137→
   138→        # 计算距上次订单时间
   139→        time_since_last = 0.0
   140→        if self._last_order_time > 0:
   141→            time_since_last = now - self._last_order_time
   142→
   143→        # 检查频率限制
   144→        if orders_in_window >= self._config.max_orders_per_minute:
   145→            self._reject_count += 1
   146→            wait_time = self._order_times[0] + self._config.window_s - now
   147→            return ThrottleCheckOutput(
   148→                result=ThrottleCheckResult.RATE_LIMIT_EXCEEDED,
   149→                orders_in_window=orders_in_window,
   150→                time_since_last=time_since_last,
   151→                wait_time_s=max(0, wait_time),
   152→                message=f"Rate limit: {orders_in_window} >= {self._config.max_orders_per_minute}",
   153→            )
   154→
   155→        # 检查最小间隔
   156→        if self._last_order_time > 0 and time_since_last < self._config.min_interval_s:
   157→            self._reject_count += 1
   158→            wait_time = self._config.min_interval_s - time_since_last
   159→            return ThrottleCheckOutput(
   160→                result=ThrottleCheckResult.MIN_INTERVAL_VIOLATED,
   161→                orders_in_window=orders_in_window,
   162→                time_since_last=time_since_last,
   163→                wait_time_s=max(0, wait_time),
   164→                message=f"Min interval: {time_since_last:.2f}s < {self._config.min_interval_s}s",
   165→            )
   166→
   167→        # 通过
   168→        return ThrottleCheckOutput(
   169→            result=ThrottleCheckResult.PASS,
   170→            orders_in_window=orders_in_window,
   171→            time_since_last=time_since_last,
   172→            wait_time_s=0.0,
   173→            message="Throttle check passed",
   174→        )
   175→
   176→    def record_order(self, now: float | None = None) -> None:
   177→        """记录订单.
   178→
   179→        在订单成功提交后调用。
   180→
   181→        Args:
   182→            now: 当前时间戳
   183→        """
   184→        if now is None:
   185→            now = time.time()
   186→
   187→        self._order_times.append(now)
   188→        self._last_order_time = now
   189→
   190→    def check_and_record(self, now: float | None = None) -> ThrottleCheckOutput:
   191→        """检查并记录.
   192→
   193→        如果检查通过，自动记录订单。
   194→
   195→        Args:
   196→            now: 当前时间戳
   197→
   198→        Returns:
   199→            检查输出
   200→        """
   201→        if now is None:
   202→            now = time.time()
   203→
   204→        result = self.check(now)
   205→        if result.passed():
   206→            self.record_order(now)
   207→
   208→        return result
   209→
   210→    def _cleanup(self, now: float) -> None:
   211→        """清理过期记录.
   212→
   213→        Args:
   214→            now: 当前时间戳
   215→        """
   216→        cutoff = now - self._config.window_s
   217→        while self._order_times and self._order_times[0] < cutoff:
   218→            self._order_times.popleft()
   219→
   220→    def get_remaining_capacity(self, now: float | None = None) -> int:
   221→        """获取剩余容量.
   222→
   223→        Args:
   224→            now: 当前时间戳
   225→
   226→        Returns:
   227→            剩余可下订单数
   228→        """
   229→        if now is None:
   230→            now = time.time()
   231→
   232→        self._cleanup(now)
   233→        return max(0, self._config.max_orders_per_minute - len(self._order_times))
   234→
   235→    def get_next_available_time(self, now: float | None = None) -> float:
   236→        """获取下一个可用时间.
   237→
   238→        Args:
   239→            now: 当前时间戳
   240→
   241→        Returns:
   242→            下一个可下单的时间戳
   243→        """
   244→        if now is None:
   245→            now = time.time()
   246→
   247→        # 检查频率限制
   248→        self._cleanup(now)
   249→        if len(self._order_times) >= self._config.max_orders_per_minute:
   250→            return self._order_times[0] + self._config.window_s
   251→
   252→        # 检查最小间隔
   253→        if self._last_order_time > 0:
   254→            next_by_interval = self._last_order_time + self._config.min_interval_s
   255→            if next_by_interval > now:
   256→                return next_by_interval
   257→
   258→        return now
   259→
   260→    def reset(self) -> None:
   261→        """重置节流器."""
   262→        self._order_times.clear()
   263→        self._last_order_time = 0.0
   264→
   265→    def get_stats(self) -> dict[str, Any]:
   266→        """获取统计信息.
   267→
   268→        Returns:
   269→            统计字典
   270→        """
   271→        return {
   272→            "check_count": self._check_count,
   273→            "reject_count": self._reject_count,
   274→            "pass_rate": (
   275→                (self._check_count - self._reject_count) / self._check_count
   276→                if self._check_count > 0
   277→                else 0.0
   278→            ),
   279→            "orders_in_window": len(self._order_times),
   280→            "remaining_capacity": self.get_remaining_capacity(),
   281→        }
   282→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
