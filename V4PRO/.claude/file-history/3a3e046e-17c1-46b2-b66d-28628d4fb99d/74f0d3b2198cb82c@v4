"""网关工厂实现

提供统一的网关创建接口，支持多种类型的行情网关。
"""

import logging
from typing import Dict, Any, Optional, Type, List
from .base import MarketGateway
from .ctp_gateway import CtpMarketGateway
from .exceptions import ConfigError

logger = logging.getLogger(__name__)

# 工厂类常量定义
DEFAULT_GATEWAY_NAME = "unnamed"  # 默认网关名称
MAX_TYPE_LENGTH = 50  # 网关类型名称最大长度


class GatewayFactory:
    """网关工厂类

    根据配置创建不同类型的行情网关实例。
    支持动态注册新的网关类型。

    使用示例:
        # 创建CTP网关
        config = {"name": "my_gateway", "type": "ctp", ...}
        gateway = GatewayFactory.create_gateway(config)

        # 注册自定义网关类型
        GatewayFactory.register_gateway_type("custom", CustomGateway)
    """

    # 支持的网关类型映射
    # 为什么使用字典：提供O(1)时间复杂度的类型查找
    # 为什么默认注册CTP：作为系统的主要网关类型
    _gateway_types: Dict[str, Type[MarketGateway]] = {
        "ctp": CtpMarketGateway,
        # 可以在这里添加其他类型的网关
        # "ib": IbMarketGateway,
        # "binance": BinanceMarketGateway,
    }

    def __repr__(self) -> str:
        """返回工厂类的字符串表示
        
        Returns:
            str: 类名和当前注册的网关类型数量
        """
        return f"{self.__class__.__name__}(registered_types={len(self._gateway_types)})"

    @classmethod
    def create_gateway(cls, config: Dict[str, Any]) -> MarketGateway:
        """根据配置创建网关实例

        Args:
            config: 网关配置字典，必须包含 'type' 字段

        Returns:
            MarketGateway: 网关实例

        Raises:
            ValueError: 当配置缺少 'type' 字段或网关类型不支持时
            ConfigError: 当配置验证失败时
        """
        # 检查必需的type字段 # REVIEW: 确保配置包含必需的类型字段以避免后续错误
        # 为什么需要检查type字段：防止因缺少类型信息导致的运行时错误
        if "type" not in config:
            error_msg = "Gateway configuration must include 'type' field"
            logger.error(error_msg)
            raise ValueError(error_msg)

        # 转换为小写以实现大小写不敏感 # REVIEW: 统一处理大小写提高容错性
        # 为什么转为小写：提升用户体验，避免因大小写导致的配置错误
        gateway_type = config["type"].lower()

        # 查找对应的网关类 # REVIEW: 通过类型映射获取具体实现类
        # 为什么使用get方法：避免KeyError异常，提供更优雅的错误处理
        gateway_class = cls._gateway_types.get(gateway_type)
        if gateway_class is None:
            # 构造详细的错误信息 # REVIEW: 提供明确的错误信息帮助用户诊断问题
            # 为什么列出支持的类型：帮助用户快速识别可用选项
            supported = ", ".join(cls._gateway_types.keys())
            error_msg = f"Unsupported gateway type: '{gateway_type}'. Supported types: {supported}"
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            # 创建网关实例 # REVIEW: 使用配置初始化具体的网关实例
            # 为什么直接传入config：保持配置的一致性和完整性
            gateway = gateway_class(config)
            # 记录成功创建的日志 # REVIEW: 提供操作审计跟踪
            # 为什么记录日志：便于监控和调试
            gateway_name = config.get('name', DEFAULT_GATEWAY_NAME)
            logger.info(f"Created {gateway_type} gateway: {gateway_name}")
            return gateway

        except ConfigError:
            # 直接抛出配置错误 # REVIEW: 保持配置错误的原始上下文
            # 为什么直接抛出：保持错误的原始上下文，便于定位问题
            raise
        except Exception as e:
            # 捕获并包装其他异常 # REVIEW: 提供统一的错误处理界面
            # 为什么包装异常：隐藏实现细节，提供统一的错误接口
            logger.error(f"Failed to create {gateway_type} gateway: {str(e)}")
            raise ConfigError(f"Gateway creation failed: {str(e)}")

    @classmethod
    def register_gateway_type(
        cls,
        gateway_type: str,
        gateway_class: Type[MarketGateway]
    ) -> None:
        """注册新的网关类型

        Args:
            gateway_type: 网关类型名称（大小写不敏感）
            gateway_class: 网关类，必须是 MarketGateway 的子类

        Raises:
            TypeError: 当 gateway_class 不是 MarketGateway 的子类时
            ValueError: 当 gateway_type 为空或过长时
        """
        # 验证类型名称有效性 # REVIEW: 防止无效或恶意的类型名称注册
        # 为什么检查空值：防止注册无效的类型名称
        if not gateway_type or not gateway_type.strip():
            raise ValueError("Gateway type cannot be empty")
        
        # 限制类型名称长度防止滥用 # REVIEW: 控制输入长度避免内存问题
        # 为什么限制长度：防止恶意输入导致内存问题
        stripped_type = gateway_type.strip()
        if len(stripped_type) > MAX_TYPE_LENGTH:
            raise ValueError(f"Gateway type exceeds maximum length of {MAX_TYPE_LENGTH}")

        # 验证类是否为MarketGateway的子类 # REVIEW: 确保类型安全性
        # 为什么检查类型：防止注册不兼容的类导致运行时错误
        if not (isinstance(gateway_class, type) and issubclass(gateway_class, MarketGateway)):
            raise TypeError(
                f"gateway_class must be a subclass of MarketGateway, "
                f"got {type(gateway_class).__name__}"
            )

        # 转换为小写并注册 # REVIEW: 统一大小写处理实现不区分大小写的查找
        # 为什么转为小写：实现大小写不敏感的类型查找
        type_lower = stripped_type.lower()
        cls._gateway_types[type_lower] = gateway_class
        logger.info(f"Registered gateway type: {type_lower}")

    @classmethod
    def unregister_gateway_type(cls, gateway_type: str) -> bool:
        """取消注册网关类型

        Args:
            gateway_type: 网关类型名称

        Returns:
            bool: 是否成功取消注册
            
        RISK: 线程安全问题 - 在多线程环境中修改共享字典可能导致竞态条件
        缓解措施: 在应用层面确保工厂类的线程安全，或在调用时加锁保护
        """
        # 转换为小写进行查找 # REVIEW: 保持与注册时一致的大小写处理
        # 为什么转换为小写：保持与注册时一致的大小写处理，确保查找一致性
        type_lower = gateway_type.lower().strip()
        if type_lower in cls._gateway_types:
            # 删除类型映射 # REVIEW: 释放不再需要的资源
            # 为什么删除：释放不再需要的资源，避免内存泄漏
            del cls._gateway_types[type_lower]
            logger.info(f"Unregistered gateway type: {type_lower}")
            return True
        # 类型不存在时返回False # REVIEW: 提供明确的操作结果反馈
        # 为什么返回False：提供明确的操作结果反馈，便于调用方处理
        return False

    @classmethod
    def get_supported_types(cls) -> List[str]:
        """获取支持的网关类型列表

        Returns:
            List[str]: 支持的网关类型名称列表
            
        RISK: 数据一致性问题 - 返回的列表是副本，不会反映后续的注册/注销变化
        缓解措施: 每次调用都返回新的列表副本，确保调用方获得最新数据
        """
        # 返回当前注册的所有类型 # REVIEW: 提供查询接口方便外部使用
        # 为什么返回副本：避免外部修改内部状态，保持封装性
        # 为什么每次都创建新列表：确保调用方获得最新的数据快照
        return list(cls._gateway_types.keys())

    @classmethod
    def is_type_supported(cls, gateway_type: str) -> bool:
        """检查网关类型是否支持

        Args:
            gateway_type: 网关类型名称

        Returns:
            bool: 是否支持该类型
            
        RISK: 大小写处理一致性 - 必须与注册时的处理方式保持一致
        缓解措施: 使用相同的大小写转换逻辑确保一致性
        """
        # 转换为小写进行查找 # REVIEW: 实现大小写不敏感的类型检查
        # 为什么转换为小写：与注册时保持一致的大小写处理，确保查找准确性
        # 为什么使用strip：去除首尾空白字符，提高容错性
        return gateway_type.lower().strip() in cls._gateway_types

    @classmethod
    def get_gateway_class(cls, gateway_type: str) -> Optional[Type[MarketGateway]]:
        """获取网关类

        Args:
            gateway_type: 网关类型名称

        Returns:
            Type[MarketGateway]: 网关类，如果不存在则返回None
            
        RISK: None值处理 - 调用方必须处理返回None的情况
        缓解措施: 在方法文档中明确说明可能返回None，调用方需进行空值检查
        """
        # 转换为小写进行查找 # REVIEW: 保持一致性处理
        # 为什么转换为小写：与注册和查找逻辑保持一致，确保准确性
        # 为什么使用get方法而不是直接访问：避免KeyError，提供安全的访问方式
        return cls._gateway_types.get(gateway_type.lower().strip())


__all__ = ['GatewayFactory']