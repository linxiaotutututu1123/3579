"""
Tick数据模型
"""

import json
from pydantic import BaseModel, Field, field_validator, ConfigDict
from datetime import datetime as dt
from decimal import Decimal
from typing import Optional, Dict, Any, List
from enum import Enum

# 常量定义 - 为什么定义常量：避免魔法数字，提高代码可维护性
DEFAULT_SYMBOL_LENGTH = 16  # 默认合约代码最大长度
DEFAULT_EXCHANGE_LENGTH = 8  # 默认交易所代码最大长度
MAX_TOLERANCE_SECONDS = 300  # 最大容忍时间差（秒）
MAX_VOLUME = 1000000000      # 最大成交量限制

class TickDataQuality(Enum):
    """数据质量等级"""
    EXCELLENT = "excellent"  # 优质数据
    GOOD = "good"            # 良好数据
    FAIR = "fair"            # 一般数据
    POOR = "poor"            # 劣质数据

class TickData(BaseModel):
    """Tick行情数据模型

    包含标准化的行情数据字段，支持数据验证和转换
    """
    # 注意：Pydantic V2 BaseModel 不支持 __slots__，已移除

    # 合约基本信息
    symbol: str = Field(..., max_length=DEFAULT_SYMBOL_LENGTH, description="合约代码，如'rb2401'")
    exchange: str = Field(..., max_length=DEFAULT_EXCHANGE_LENGTH, description="交易所代码，如'SHFE'")
    
    # 时间戳信息
    datetime: dt = Field(..., description="行情时间戳（交易所时间）")
    local_datetime: dt = Field(..., description="本地接收时间戳")
    
    # 最新价信息
    last_price: Decimal = Field(..., description="最新价")
    volume: int = Field(..., description="成交量（累计）")
    turnover: Decimal = Field(..., description="成交额（累计）")
    open_interest: int = Field(..., description="持仓量")
    
    # Level1 数据 - 买卖盘
    bid_price_1: Decimal = Field(..., description="买一价")
    bid_volume_1: int = Field(..., description="买一量")
    ask_price_1: Decimal = Field(..., description="卖一价")
    ask_volume_1: int = Field(..., description="卖一量")
    
    # 数据质量信息
    source: str = Field(default="unknown", max_length=32, description="数据来源")
    quality: TickDataQuality = Field(default=TickDataQuality.GOOD, description="数据质量等级")
    is_valid: bool = Field(default=True, description="数据是否有效")
    validation_errors: Optional[List[str]] = Field(None, description="验证错误信息")
    
    model_config = ConfigDict(
        # Pydantic V2不再使用json_encoders，而是使用model_serializer
    )
    
    def model_dump_json(self, **kwargs) -> str:
        """序列化为JSON字符串，自定义datetime和Decimal的格式
        
        Returns:
            str: JSON字符串
        """
        def custom_serializer(obj):
            if isinstance(obj, dt):
                return obj.strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            elif isinstance(obj, Decimal):
                return float(obj)
            return str(obj)
        
        import json
        return json.dumps(self.model_dump(), default=custom_serializer, **kwargs)
    
    @field_validator('last_price', mode='before')
    @classmethod
    def validate_last_price(cls, v):
        """验证最新价有效性
        
        为什么验证价格：防止异常价格数据影响交易决策和风险控制
        
        Args:
            v: 待验证的价格值
            
        Returns:
            Decimal: 验证后的价格值
            
        Raises:
            ValueError: 当价格无效时抛出
        """
        if v is None:
            return v
        # 最新价必须为正数 - 为什么检查正数：负价格在金融市场中无意义
        if isinstance(v, (int, float, Decimal)) and v <= 0:
            raise ValueError("最新价必须为正数")
        
        # RISK: 价格精度问题可能导致计算错误
        # 为什么转换为Decimal：避免浮点数精度问题
        decimal_value = Decimal(str(v))
        exponent = decimal_value.as_tuple().exponent
        if isinstance(exponent, int) and exponent < -10:  # 小数点后超过10位
            raise ValueError("价格精度过高，最多支持10位小数")
        
        return decimal_value

    @field_validator('bid_price_1', 'ask_price_1', mode='before')
    @classmethod
    def validate_quote_price(cls, v):
        """验证买卖盘价格有效性
        
        为什么验证报价价格：确保买卖盘数据的合理性，防止异常报价
        
        Args:
            v: 待验证的价格值
            
        Returns:
            Decimal: 验证后的价格值
            
        Raises:
            ValueError: 当价格无效时抛出
        """
        if v is None:
            return v
        # 买卖盘价格可以为0（无报价时）但不能为负数
        if isinstance(v, (int, float, Decimal)) and v < 0:
            raise ValueError("价格不能为负数")
        
        # RISK: 报价价格精度问题可能导致计算错误
        # 为什么转换为Decimal：避免浮点数精度问题
        decimal_value = Decimal(str(v))
        exponent = decimal_value.as_tuple().exponent
        if isinstance(exponent, int) and exponent < -10:  # 小数点后超过10位
            raise ValueError("报价价格精度过高，最多支持10位小数")
        
        return decimal_value
    
    @field_validator('volume', 'bid_volume_1', 'ask_volume_1', 'open_interest', mode='before')
    @classmethod
    def validate_volume(cls, v):
        """验证成交量有效性
        
        为什么验证成交量：防止异常成交量数据影响统计分析和风险控制
        
        Args:
            v: 待验证的成交量值
            
        Returns:
            int: 验证后的成交量值
            
        Raises:
            ValueError: 当成交量无效时抛出
        """
        if v is None:
            return v
        # 成交量不能为负数 - 为什么检查负数：负成交量在金融市场中无意义
        if isinstance(v, int) and v < 0:
            raise ValueError("成交量不能为负数")
        
        # RISK: 异常大的成交量可能导致系统性能问题
        # 为什么检查上限：防止异常值导致内存或计算问题
        if isinstance(v, int) and v > MAX_VOLUME:
            raise ValueError(f"成交量超过最大限制 {MAX_VOLUME}")
        
        return int(v)
    
    @field_validator('datetime', 'local_datetime', mode='before')
    @classmethod
    def validate_datetime(cls, v):
        """验证时间戳有效性
        
        为什么验证时间戳：确保时间数据的合理性和一致性
        
        Args:
            v: 待验证的时间戳值
            
        Returns:
            datetime: 验证后的时间戳
            
        Raises:
            ValueError: 当时间戳无效时抛出
        """
        if isinstance(v, str):
            try:
                # RISK: 时间解析错误可能导致数据丢失
                # 为什么使用fromisoformat：支持ISO格式时间字符串解析
                return dt.fromisoformat(v)
            except ValueError:
                raise ValueError("时间戳格式无效，请使用ISO格式(YYYY-MM-DD HH:MM:SS)")
        
        # 检查datetime对象是否合理
        if isinstance(v, dt):
            # 为什么检查年份范围：防止异常时间戳
            if v.year < 2000 or v.year > 2100:
                raise ValueError(f"时间戳年份超出合理范围(2000-2100): {v.year}")
            return v
        
        return v
    
    def __repr__(self) -> str:
        """返回TickData对象的字符串表示，便于调试
        
        为什么自定义__repr__：提供简洁而有意义的对象表示，便于调试和日志记录
        
        Returns:
            str: TickData的字符串表示
        """
        return (f"TickData(symbol='{self.symbol}', exchange='{self.exchange}', "
                f"last_price={self.last_price}, volume={self.volume}, "
                f"datetime='{self.datetime.strftime('%Y-%m-%d %H:%M:%S')}')")
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式，便于序列化
        
        为什么提供to_dict方法：统一数据序列化接口，便于与其他系统集成
        
        Returns:
            Dict[str, Any]: 字典格式的Tick数据
        """
        return self.model_dump()
    
    @classmethod
    def from_raw_data(cls, raw_data: Dict[str, Any], source: str = "unknown") -> 'TickData':
        """从原始数据创建TickData对象
        
        为什么提供from_raw_data方法：统一数据转换接口，便于从不同数据源创建TickData对象
        
        Args:
            raw_data: 原始行情数据字典，应包含必要字段
            source: 数据来源标识，用于数据追溯和质量控制
            
        Returns:
            TickData: 标准化的TickData对象
            
        Raises:
            ValueError: 当原始数据缺少必要字段时
            TypeError: 当原始数据类型不正确时
        """
        # RISK: 原始数据格式错误可能导致异常
        # 为什么检查数据类型：确保输入数据为字典类型
        if not isinstance(raw_data, dict):
            raise TypeError(f"原始数据必须为字典类型，当前类型: {type(raw_data).__name__}")
        
        # 检查必要字段是否存在
        required_fields = ['symbol', 'exchange', 'datetime', 'last_price']
        for field in required_fields:
            if field not in raw_data:
                raise ValueError(f"缺少必要字段: {field}")
        
        # 构建TickData对象
        tick_data = {
            "symbol": raw_data["symbol"],
            "exchange": raw_data["exchange"],
            "datetime": raw_data["datetime"],
            "local_datetime": raw_data.get("local_datetime", dt.now()),
            "last_price": raw_data["last_price"],
            "volume": raw_data.get("volume", 0),
            "turnover": raw_data.get("turnover", Decimal("0")),
            "open_interest": raw_data.get("open_interest", 0),
            "bid_price_1": raw_data.get("bid_price_1", Decimal("0")),
            "ask_price_1": raw_data.get("ask_price_1", Decimal("0")),
            "bid_volume_1": raw_data.get("bid_volume_1", 0),
            "ask_volume_1": raw_data.get("ask_volume_1", 0),
            "source": source,
            "quality": raw_data.get("quality", TickDataQuality.GOOD),
            "is_valid": raw_data.get("is_valid", True),
            "validation_errors": raw_data.get("validation_errors", None)
        }
        
        return cls(**tick_data)
    
    def is_stale(self, tolerance_seconds: int = 30) -> bool:
        """检查数据是否过期
        
        为什么检查数据新鲜度：确保使用的是最新数据，避免基于过期数据做出决策
        
        Args:
            tolerance_seconds: 容忍的时间差（秒），默认30秒
            
        Returns:
            bool: 是否过期
            
        Raises:
            ValueError: 当容忍时间差无效时抛出
        """
        # RISK: 无效的容忍时间可能导致逻辑错误
        # 为什么验证tolerance_seconds：确保参数在合理范围内
        if tolerance_seconds < 0:
            raise ValueError("容忍时间差不能为负数")
        if tolerance_seconds > MAX_TOLERANCE_SECONDS:
            raise ValueError(f"容忍时间差不能超过最大限制 {MAX_TOLERANCE_SECONDS} 秒")
        
        now = dt.now()
        time_diff = (now - self.datetime).total_seconds()
        return time_diff > tolerance_seconds

__all__ = ['TickData', 'TickDataQuality']