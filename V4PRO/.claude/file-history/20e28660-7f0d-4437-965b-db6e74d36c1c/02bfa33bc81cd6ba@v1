"""
程序化交易合规模块 - ProgrammaticTradingCompliance (军规级 v4.0).

V4PRO Platform Component - Phase 7 中国期货市场特化
V4 SPEC: §12 Phase 7, §21 程序化交易合规
V4 Scenarios:
- CHINA.COMPLIANCE.RULE_CHECK: 合规规则检查
- CHINA.COMPLIANCE.REPORT_FREQUENCY: 报撤单频率检查

军规覆盖:
- M17: 程序化合规 - 报撤单频率必须在监管阈值内

功能特性:
- 报撤单频率监控 (5秒/日统计)
- 高频交易判定 (2025年7月7日新规)
- 四级预警机制 (NORMAL/WARNING/CRITICAL/EXCEEDED)
- 合规节流器 (ComplianceThrottle)

监管规则 (2025年《期货市场程序化交易管理规定》):
- 5秒内报撤单预警阈值: 50笔
- 单秒高频交易判定: ≥300笔
- 单日高频交易判定: ≥20000笔

示例:
    >>> from src.compliance.programmatic_trading import (
    ...     ComplianceThrottle,
    ...     ThrottleLevel,
    ...     ProgrammaticTradingCompliance,
    ... )
    >>> compliance = ProgrammaticTradingCompliance()
    >>> can_trade, msg = compliance.can_submit()
"""

from __future__ import annotations

from collections import deque
from dataclasses import dataclass, field
from datetime import date, datetime
from enum import Enum
from typing import Any


class ThrottleLevel(Enum):
    """节流等级枚举."""

    NORMAL = "NORMAL"  # 正常交易
    WARNING = "WARNING"  # 预警 (接近限制)
    CRITICAL = "CRITICAL"  # 临界 (暂停新开仓)
    EXCEEDED = "EXCEEDED"  # 超限 (停止所有报撤单)


class OrderAction(Enum):
    """订单操作类型枚举."""

    SUBMIT = "SUBMIT"  # 报单
    CANCEL = "CANCEL"  # 撤单
    AMEND = "AMEND"  # 改单


@dataclass(frozen=True)
class ThrottleConfig:
    """节流配置 (不可变).

    属性:
        limit_5s: 5秒报撤单限制 (默认50)
        limit_daily: 日报撤单限制 (默认20000)
        warning_ratio: 预警比例 (默认0.6)
        critical_ratio: 临界比例 (默认0.9)
        high_freq_per_sec: 高频判定每秒阈值 (默认300)
        cooldown_seconds: 超限冷却时间 (默认60秒)
    """

    limit_5s: int = 50
    limit_daily: int = 20000
    warning_ratio: float = 0.6
    critical_ratio: float = 0.9
    high_freq_per_sec: int = 300
    cooldown_seconds: int = 60


@dataclass
class OrderRecord:
    """订单记录.

    属性:
        timestamp: 时间戳
        action: 操作类型
        symbol: 合约代码
        order_id: 订单ID
    """

    timestamp: datetime
    action: OrderAction
    symbol: str
    order_id: str = ""


@dataclass
class ThrottleStatus:
    """节流状态.

    属性:
        level: 当前等级
        count_5s: 5秒计数
        count_daily: 日计数
        count_per_sec: 每秒计数
        usage_5s_pct: 5秒使用率
        usage_daily_pct: 日使用率
        is_high_freq: 是否高频交易
        can_submit: 是否可以报单
        message: 状态消息
        last_check: 最后检查时间
    """

    level: ThrottleLevel
    count_5s: int
    count_daily: int
    count_per_sec: int
    usage_5s_pct: float
    usage_daily_pct: float
    is_high_freq: bool
    can_submit: bool
    message: str
    last_check: str = ""


@dataclass
class ComplianceReport:
    """合规报告.

    属性:
        date: 报告日期
        total_orders: 总订单数
        total_cancels: 总撤单数
        total_amends: 总改单数
        max_5s_count: 5秒最大计数
        max_per_sec_count: 每秒最大计数
        warning_count: 预警触发次数
        critical_count: 临界触发次数
        exceeded_count: 超限触发次数
        is_high_freq: 是否被判定为高频
        violations: 违规详情
    """

    date: date
    total_orders: int = 0
    total_cancels: int = 0
    total_amends: int = 0
    max_5s_count: int = 0
    max_per_sec_count: int = 0
    warning_count: int = 0
    critical_count: int = 0
    exceeded_count: int = 0
    is_high_freq: bool = False
    violations: list[dict[str, Any]] = field(default_factory=list)


class ComplianceThrottle:
    """合规节流器 (军规 M17).

    功能:
    - 记录报撤单操作
    - 计算5秒/每秒/日统计
    - 判断节流等级
    - 决定是否允许新操作

    示例:
        >>> throttle = ComplianceThrottle()
        >>> can, msg = throttle.can_submit()
        >>> if can:
        ...     throttle.record_order(OrderAction.SUBMIT, "rb2501")
    """

    def __init__(self, config: ThrottleConfig | None = None) -> None:
        """初始化节流器.

        参数:
            config: 节流配置 (None使用默认配置)
        """
        self._config = config or ThrottleConfig()
        self._records: deque[OrderRecord] = deque(maxlen=100000)
        self._current_date: date | None = None
        self._daily_count: int = 0
        self._level: ThrottleLevel = ThrottleLevel.NORMAL
        self._exceeded_until: datetime | None = None

    @property
    def config(self) -> ThrottleConfig:
        """获取配置."""
        return self._config

    @property
    def level(self) -> ThrottleLevel:
        """获取当前等级."""
        return self._level

    @property
    def daily_count(self) -> int:
        """获取日计数."""
        return self._daily_count

    def record_order(
        self,
        action: OrderAction,
        symbol: str,
        order_id: str = "",
        timestamp: datetime | None = None,
    ) -> ThrottleStatus:
        """记录订单操作.

        参数:
            action: 操作类型
            symbol: 合约代码
            order_id: 订单ID
            timestamp: 时间戳 (None使用当前时间)

        返回:
            节流状态
        """
        if timestamp is None:
            timestamp = datetime.now()  # noqa: DTZ005

        # 检查日期切换
        current_date = timestamp.date()
        if self._current_date is None or current_date != self._current_date:
            self._reset_daily(current_date)

        # 记录操作
        record = OrderRecord(
            timestamp=timestamp,
            action=action,
            symbol=symbol,
            order_id=order_id,
        )
        self._records.append(record)
        self._daily_count += 1

        # 更新状态
        return self._update_status(timestamp)

    def can_submit(self, timestamp: datetime | None = None) -> tuple[bool, str]:
        """检查是否可以报单.

        参数:
            timestamp: 检查时间 (None使用当前时间)

        返回:
            (是否允许, 消息)
        """
        if timestamp is None:
            timestamp = datetime.now()  # noqa: DTZ005

        # 检查冷却期
        if self._exceeded_until and timestamp < self._exceeded_until:
            remaining = (self._exceeded_until - timestamp).seconds
            return False, f"超限冷却中, 剩余{remaining}秒"

        # 更新状态
        status = self._update_status(timestamp)

        if status.level == ThrottleLevel.EXCEEDED:
            return False, "报撤单频率超限, 已停止交易"

        if status.level == ThrottleLevel.CRITICAL:
            return True, "接近限制, 仅允许平仓"

        if status.level == ThrottleLevel.WARNING:
            return True, f"预警: 5秒计数{status.count_5s}/{self._config.limit_5s}"

        return True, "正常"

    def get_status(self, timestamp: datetime | None = None) -> ThrottleStatus:
        """获取当前状态.

        参数:
            timestamp: 检查时间

        返回:
            节流状态
        """
        if timestamp is None:
            timestamp = datetime.now()  # noqa: DTZ005
        return self._update_status(timestamp)

    def get_count_5s(self, timestamp: datetime | None = None) -> int:
        """获取5秒计数.

        参数:
            timestamp: 检查时间

        返回:
            5秒内报撤单数
        """
        if timestamp is None:
            timestamp = datetime.now()  # noqa: DTZ005
        return self._count_in_window(timestamp, seconds=5)

    def get_count_per_sec(self, timestamp: datetime | None = None) -> int:
        """获取每秒计数.

        参数:
            timestamp: 检查时间

        返回:
            当前秒报撤单数
        """
        if timestamp is None:
            timestamp = datetime.now()  # noqa: DTZ005
        return self._count_in_window(timestamp, seconds=1)

    def is_high_frequency(self, timestamp: datetime | None = None) -> bool:
        """判断是否高频交易.

        参数:
            timestamp: 检查时间

        返回:
            是否高频交易
        """
        if timestamp is None:
            timestamp = datetime.now()  # noqa: DTZ005

        # 每秒≥300笔 或 日≥20000笔
        per_sec = self.get_count_per_sec(timestamp)
        if per_sec >= self._config.high_freq_per_sec:
            return True
        return self._daily_count >= self._config.limit_daily

    def reset(self) -> None:
        """重置节流器."""
        self._records.clear()
        self._current_date = None
        self._daily_count = 0
        self._level = ThrottleLevel.NORMAL
        self._exceeded_until = None

    def _reset_daily(self, new_date: date) -> None:
        """重置日统计.

        参数:
            new_date: 新日期
        """
        self._current_date = new_date
        self._daily_count = 0
        self._level = ThrottleLevel.NORMAL
        self._exceeded_until = None

        # 清理过期记录 (保留当天)
        if self._records:
            while self._records and self._records[0].timestamp.date() != new_date:
                self._records.popleft()

    def _count_in_window(self, timestamp: datetime, seconds: int) -> int:
        """计算时间窗口内的记录数.

        参数:
            timestamp: 结束时间
            seconds: 窗口秒数

        返回:
            记录数
        """
        from datetime import timedelta

        window_start = timestamp - timedelta(seconds=seconds)
        count = 0
        for record in reversed(self._records):
            if record.timestamp < window_start:
                break
            if record.timestamp <= timestamp:
                count += 1
        return count

    def _update_status(self, timestamp: datetime) -> ThrottleStatus:
        """更新并返回状态.

        参数:
            timestamp: 当前时间

        返回:
            节流状态
        """
        count_5s = self._count_in_window(timestamp, 5)
        count_per_sec = self._count_in_window(timestamp, 1)

        # 计算使用率
        usage_5s_pct = count_5s / self._config.limit_5s if self._config.limit_5s > 0 else 0
        usage_daily_pct = (
            self._daily_count / self._config.limit_daily if self._config.limit_daily > 0 else 0
        )

        # 判断高频
        is_high_freq = (
            count_per_sec >= self._config.high_freq_per_sec
            or self._daily_count >= self._config.limit_daily
        )

        # 确定等级
        level = self._calculate_level(usage_5s_pct, usage_daily_pct, count_5s)
        self._level = level

        # 触发超限冷却
        if level == ThrottleLevel.EXCEEDED and self._exceeded_until is None:
            from datetime import timedelta

            self._exceeded_until = timestamp + timedelta(seconds=self._config.cooldown_seconds)

        # 生成消息和可提交状态
        can_submit = level != ThrottleLevel.EXCEEDED
        message = self._get_status_message(level, count_5s, self._daily_count)

        return ThrottleStatus(
            level=level,
            count_5s=count_5s,
            count_daily=self._daily_count,
            count_per_sec=count_per_sec,
            usage_5s_pct=usage_5s_pct,
            usage_daily_pct=usage_daily_pct,
            is_high_freq=is_high_freq,
            can_submit=can_submit,
            message=message,
            last_check=timestamp.isoformat(),
        )

    def _calculate_level(
        self,
        usage_5s_pct: float,
        usage_daily_pct: float,
        count_5s: int,
    ) -> ThrottleLevel:
        """计算节流等级.

        参数:
            usage_5s_pct: 5秒使用率
            usage_daily_pct: 日使用率
            count_5s: 5秒计数

        返回:
            节流等级
        """
        # 超过限制
        if count_5s >= self._config.limit_5s:
            return ThrottleLevel.EXCEEDED
        if self._daily_count >= self._config.limit_daily:
            return ThrottleLevel.EXCEEDED

        # 临界
        if usage_5s_pct >= self._config.critical_ratio:
            return ThrottleLevel.CRITICAL
        if usage_daily_pct >= self._config.critical_ratio:
            return ThrottleLevel.CRITICAL

        # 预警
        if usage_5s_pct >= self._config.warning_ratio:
            return ThrottleLevel.WARNING
        if usage_daily_pct >= self._config.warning_ratio:
            return ThrottleLevel.WARNING

        return ThrottleLevel.NORMAL

    def _get_status_message(
        self,
        level: ThrottleLevel,
        count_5s: int,
        count_daily: int,
    ) -> str:
        """生成状态消息.

        参数:
            level: 节流等级
            count_5s: 5秒计数
            count_daily: 日计数

        返回:
            状态消息
        """
        messages = {
            ThrottleLevel.NORMAL: f"正常, 5秒:{count_5s}/{self._config.limit_5s}, 日:{count_daily}/{self._config.limit_daily}",
            ThrottleLevel.WARNING: f"预警! 5秒:{count_5s}/{self._config.limit_5s}, 日:{count_daily}/{self._config.limit_daily}",
            ThrottleLevel.CRITICAL: f"临界! 5秒:{count_5s}/{self._config.limit_5s}, 日:{count_daily}/{self._config.limit_daily}",
            ThrottleLevel.EXCEEDED: f"超限! 5秒:{count_5s}/{self._config.limit_5s}, 日:{count_daily}/{self._config.limit_daily}",
        }
        return messages.get(level, "未知状态")


class ProgrammaticTradingCompliance:
    """程序化交易合规管理器 (军规 M17).

    功能:
    - 管理合规节流器
    - 生成合规报告
    - 监控高频交易判定

    示例:
        >>> compliance = ProgrammaticTradingCompliance()
        >>> can, msg = compliance.can_submit("rb2501")
        >>> if can:
        ...     compliance.record_order(OrderAction.SUBMIT, "rb2501", "order_001")
    """

    def __init__(self, config: ThrottleConfig | None = None) -> None:
        """初始化合规管理器.

        参数:
            config: 节流配置
        """
        self._throttle = ComplianceThrottle(config)
        self._reports: dict[date, ComplianceReport] = {}
        self._order_count: int = 0
        self._cancel_count: int = 0
        self._amend_count: int = 0
        self._max_5s_count: int = 0
        self._max_per_sec_count: int = 0

    @property
    def throttle(self) -> ComplianceThrottle:
        """获取节流器."""
        return self._throttle

    def can_submit(
        self,
        symbol: str | None = None,
        timestamp: datetime | None = None,
    ) -> tuple[bool, str]:
        """检查是否可以报单.

        参数:
            symbol: 合约代码 (可选, 用于品种级限制)
            timestamp: 检查时间

        返回:
            (是否允许, 消息)
        """
        return self._throttle.can_submit(timestamp)

    def record_order(
        self,
        action: OrderAction,
        symbol: str,
        order_id: str = "",
        timestamp: datetime | None = None,
    ) -> ThrottleStatus:
        """记录订单操作.

        参数:
            action: 操作类型
            symbol: 合约代码
            order_id: 订单ID
            timestamp: 时间戳

        返回:
            节流状态
        """
        status = self._throttle.record_order(action, symbol, order_id, timestamp)

        # 更新统计
        if action == OrderAction.SUBMIT:
            self._order_count += 1
        elif action == OrderAction.CANCEL:
            self._cancel_count += 1
        elif action == OrderAction.AMEND:
            self._amend_count += 1

        # 更新最大值
        self._max_5s_count = max(self._max_5s_count, status.count_5s)
        self._max_per_sec_count = max(self._max_per_sec_count, status.count_per_sec)

        return status

    def get_status(self, timestamp: datetime | None = None) -> ThrottleStatus:
        """获取当前状态.

        参数:
            timestamp: 检查时间

        返回:
            节流状态
        """
        return self._throttle.get_status(timestamp)

    def is_high_frequency(self, timestamp: datetime | None = None) -> bool:
        """判断是否高频交易.

        参数:
            timestamp: 检查时间

        返回:
            是否高频交易
        """
        return self._throttle.is_high_frequency(timestamp)

    def generate_report(self, report_date: date | None = None) -> ComplianceReport:
        """生成合规报告.

        参数:
            report_date: 报告日期 (None使用今天)

        返回:
            合规报告
        """
        if report_date is None:
            report_date = date.today()  # noqa: DTZ011

        report = ComplianceReport(
            date=report_date,
            total_orders=self._order_count,
            total_cancels=self._cancel_count,
            total_amends=self._amend_count,
            max_5s_count=self._max_5s_count,
            max_per_sec_count=self._max_per_sec_count,
            is_high_freq=self._throttle.is_high_frequency(),
        )

        self._reports[report_date] = report
        return report

    def reset_daily(self) -> None:
        """重置日统计."""
        self._throttle.reset()
        self._order_count = 0
        self._cancel_count = 0
        self._amend_count = 0
        self._max_5s_count = 0
        self._max_per_sec_count = 0


# ============================================================
# 便捷函数
# ============================================================


def get_default_throttle_config() -> ThrottleConfig:
    """获取默认节流配置.

    返回:
        默认配置
    """
    return ThrottleConfig()


def create_compliance_throttle(
    config: ThrottleConfig | None = None,
) -> ComplianceThrottle:
    """创建合规节流器.

    参数:
        config: 配置

    返回:
        节流器实例
    """
    return ComplianceThrottle(config)


def create_compliance_manager(
    config: ThrottleConfig | None = None,
) -> ProgrammaticTradingCompliance:
    """创建合规管理器.

    参数:
        config: 配置

    返回:
        管理器实例
    """
    return ProgrammaticTradingCompliance(config)
