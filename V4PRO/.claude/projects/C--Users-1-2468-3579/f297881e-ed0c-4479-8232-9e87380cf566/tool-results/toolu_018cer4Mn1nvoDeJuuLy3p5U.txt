     1→"""VaR 风险价值计算器 (军规级 v3.0).
     2→
     3→提供风险价值 (VaR) 计算功能。
     4→
     5→功能特性:
     6→- 历史模拟法 VaR
     7→- 参数法 VaR
     8→- 蒙特卡洛模拟 VaR
     9→- 预期尾部损失 (CVaR/ES)
    10→
    11→示例:
    12→    calculator = VaRCalculator()
    13→    var_95 = calculator.historical_var(returns, confidence=0.95)
    14→    cvar = calculator.expected_shortfall(returns, confidence=0.95)
    15→"""
    16→
    17→from __future__ import annotations
    18→
    19→import math
    20→from dataclasses import dataclass
    21→from typing import Any
    22→
    23→
    24→@dataclass
    25→class VaRResult:
    26→    """VaR calculation result.
    27→
    28→    Attributes:
    29→        var: Value at Risk
    30→        confidence: Confidence level
    31→        method: Calculation method
    32→        expected_shortfall: Expected shortfall (CVaR)
    33→        sample_size: Number of samples used
    34→        metadata: Additional metadata
    35→    """
    36→
    37→    var: float
    38→    confidence: float
    39→    method: str
    40→    expected_shortfall: float = 0.0
    41→    sample_size: int = 0
    42→    metadata: dict[str, Any] | None = None
    43→
    44→    def to_dict(self) -> dict[str, Any]:
    45→        """Convert to dictionary."""
    46→        return {
    47→            "var": self.var,
    48→            "confidence": self.confidence,
    49→            "method": self.method,
    50→            "expected_shortfall": self.expected_shortfall,
    51→            "sample_size": self.sample_size,
    52→            "metadata": self.metadata or {},
    53→        }
    54→
    55→
    56→class VaRCalculator:
    57→    """Value at Risk calculator.
    58→
    59→    Provides multiple methods for VaR calculation including
    60→    historical, parametric, and Monte Carlo approaches.
    61→    """
    62→
    63→    def __init__(self, default_confidence: float = 0.95) -> None:
    64→        """Initialize VaR calculator.
    65→
    66→        Args:
    67→            default_confidence: Default confidence level (0.95 = 95%)
    68→        """
    69→        self._default_confidence = default_confidence
    70→
    71→    def historical_var(self, returns: list[float], confidence: float | None = None) -> VaRResult:
    72→        """Calculate historical VaR.
    73→
    74→        Uses empirical distribution of returns to estimate VaR.
    75→
    76→        Args:
    77→            returns: List of historical returns
    78→            confidence: Confidence level (default: 0.95)
    79→
    80→        Returns:
    81→            VaR result
    82→        """
    83→        confidence = confidence or self._default_confidence
    84→
    85→        if len(returns) < 2:
    86→            return VaRResult(
    87→                var=0.0,
    88→                confidence=confidence,
    89→                method="historical",
    90→                sample_size=len(returns),
    91→            )
    92→
    93→        # Sort returns
    94→        sorted_returns = sorted(returns)
    95→        n = len(sorted_returns)
    96→
    97→        # Find percentile index
    98→        index = int((1 - confidence) * n)
    99→        index = max(0, min(index, n - 1))
   100→
   101→        var = -sorted_returns[index]  # VaR is typically positive
   102→
   103→        # Calculate expected shortfall
   104→        es = self._calculate_expected_shortfall(sorted_returns, index)
   105→
   106→        return VaRResult(
   107→            var=var,
   108→            confidence=confidence,
   109→            method="historical",
   110→            expected_shortfall=es,
   111→            sample_size=n,
   112→        )
   113→
   114→    def parametric_var(self, returns: list[float], confidence: float | None = None) -> VaRResult:
   115→        """Calculate parametric (variance-covariance) VaR.
   116→
   117→        Assumes normal distribution of returns.
   118→
   119→        Args:
   120→            returns: List of historical returns
   121→            confidence: Confidence level (default: 0.95)
   122→
   123→        Returns:
   124→            VaR result
   125→        """
   126→        confidence = confidence or self._default_confidence
   127→
   128→        if len(returns) < 2:
   129→            return VaRResult(
   130→                var=0.0,
   131→                confidence=confidence,
   132→                method="parametric",
   133→                sample_size=len(returns),
   134→            )
   135→
   136→        # Calculate mean and std
   137→        mean = sum(returns) / len(returns)
   138→        variance = sum((r - mean) ** 2 for r in returns) / (len(returns) - 1)
   139→        std = math.sqrt(variance) if variance > 0 else 0.0
   140→
   141→        # Z-score for confidence level
   142→        z = self._norm_ppf(confidence)
   143→
   144→        # VaR = -mean + z * std
   145→        var = -mean + z * std
   146→
   147→        # Expected shortfall for normal distribution
   148→        # ES = mean + std * phi(z) / (1 - confidence)
   149→        pdf_z = self._norm_pdf(z)
   150→        es = -mean + std * pdf_z / (1 - confidence) if confidence < 1 else var
   151→
   152→        return VaRResult(
   153→            var=var,
   154→            confidence=confidence,
   155→            method="parametric",
   156→            expected_shortfall=es,
   157→            sample_size=len(returns),
   158→            metadata={"mean": mean, "std": std, "z_score": z},
   159→        )
   160→
   161→    def monte_carlo_var(
   162→        self,
   163→        returns: list[float],
   164→        confidence: float | None = None,
   165→        simulations: int = 10000,
   166→        horizon: int = 1,
   167→    ) -> VaRResult:
   168→        """Calculate Monte Carlo VaR.
   169→
   170→        Simulates future returns based on historical distribution.
   171→
   172→        Args:
   173→            returns: List of historical returns
   174→            confidence: Confidence level (default: 0.95)
   175→            simulations: Number of simulations
   176→            horizon: Time horizon (days)
   177→
   178→        Returns:
   179→            VaR result
   180→        """
   181→        confidence = confidence or self._default_confidence
   182→
   183→        if len(returns) < 2:
   184→            return VaRResult(
   185→                var=0.0,
   186→                confidence=confidence,
   187→                method="monte_carlo",
   188→                sample_size=len(returns),
   189→            )
   190→
   191→        # Calculate mean and std
   192→        mean = sum(returns) / len(returns)
   193→        variance = sum((r - mean) ** 2 for r in returns) / (len(returns) - 1)
   194→        std = math.sqrt(variance) if variance > 0 else 0.0
   195→
   196→        # Scale for horizon
   197→        mean_horizon = mean * horizon
   198→        std_horizon = std * math.sqrt(horizon)
   199→
   200→        # Simulate returns (using Box-Muller for normal random numbers)
   201→        simulated_returns: list[float] = []
   202→        for _ in range(simulations // 2 + 1):
   203→            u1, u2 = self._random_uniform(), self._random_uniform()
   204→            if u1 > 0 and u2 > 0:
   205→                z1 = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2)
   206→                z2 = math.sqrt(-2 * math.log(u1)) * math.sin(2 * math.pi * u2)
   207→                simulated_returns.append(mean_horizon + std_horizon * z1)
   208→                if len(simulated_returns) < simulations:
   209→                    simulated_returns.append(mean_horizon + std_horizon * z2)
   210→
   211→        # Truncate to exact number
   212→        simulated_returns = simulated_returns[:simulations]
   213→
   214→        # Sort and find VaR
   215→        sorted_returns = sorted(simulated_returns)
   216→        index = int((1 - confidence) * len(sorted_returns))
   217→        index = max(0, min(index, len(sorted_returns) - 1))
   218→
   219→        var = -sorted_returns[index]
   220→        es = self._calculate_expected_shortfall(sorted_returns, index)
   221→
   222→        return VaRResult(
   223→            var=var,
   224→            confidence=confidence,
   225→            method="monte_carlo",
   226→            expected_shortfall=es,
   227→            sample_size=len(returns),
   228→            metadata={"simulations": simulations, "horizon": horizon},
   229→        )
   230→
   231→    def expected_shortfall(self, returns: list[float], confidence: float | None = None) -> float:
   232→        """Calculate Expected Shortfall (CVaR).
   233→
   234→        Average of losses beyond VaR.
   235→
   236→        Args:
   237→            returns: List of historical returns
   238→            confidence: Confidence level (default: 0.95)
   239→
   240→        Returns:
   241→            Expected shortfall value
   242→        """
   243→        result = self.historical_var(returns, confidence)
   244→        return result.expected_shortfall
   245→
   246→    def _calculate_expected_shortfall(self, sorted_returns: list[float], var_index: int) -> float:
   247→        """Calculate expected shortfall from sorted returns.
   248→
   249→        Args:
   250→            sorted_returns: Sorted list of returns
   251→            var_index: Index of VaR in sorted list
   252→
   253→        Returns:
   254→            Expected shortfall
   255→        """
   256→        if var_index <= 0:
   257→            return -sorted_returns[0] if sorted_returns else 0.0
   258→
   259→        # Average of returns below VaR
   260→        tail_returns = sorted_returns[:var_index]
   261→        if not tail_returns:
   262→            return 0.0
   263→
   264→        return -sum(tail_returns) / len(tail_returns)
   265→
   266→    def _norm_ppf(self, p: float) -> float:
   267→        """Normal distribution percent point function (inverse CDF).
   268→
   269→        Approximate using rational approximation.
   270→
   271→        Args:
   272→            p: Probability (0-1)
   273→
   274→        Returns:
   275→            Z-score
   276→        """
   277→        if p <= 0:
   278→            return float("-inf")
   279→        if p >= 1:
   280→            return float("inf")
   281→        if p == 0.5:
   282→            return 0.0
   283→
   284→        # Approximation constants
   285→        a = [
   286→            -3.969683028665376e01,
   287→            2.209460984245205e02,
   288→            -2.759285104469687e02,
   289→            1.383577518672690e02,
   290→            -3.066479806614716e01,
   291→            2.506628277459239e00,
   292→        ]
   293→        b = [
   294→            -5.447609879822406e01,
   295→            1.615858368580409e02,
   296→            -1.556989798598866e02,
   297→            6.680131188771972e01,
   298→            -1.328068155288572e01,
   299→        ]
   300→        c = [
   301→            -7.784894002430293e-03,
   302→            -3.223964580411365e-01,
   303→            -2.400758277161838e00,
   304→            -2.549732539343734e00,
   305→            4.374664141464968e00,
   306→            2.938163982698783e00,
   307→        ]
   308→        d = [
   309→            7.784695709041462e-03,
   310→            3.224671290700398e-01,
   311→            2.445134137142996e00,
   312→            3.754408661907416e00,
   313→        ]
   314→
   315→        p_low = 0.02425
   316→        p_high = 1 - p_low
   317→
   318→        if p < p_low:
   319→            q = math.sqrt(-2 * math.log(p))
   320→            return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / (
   321→                (((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1
   322→            )
   323→        if p <= p_high:
   324→            q = p - 0.5
   325→            r = q * q
   326→            return (
   327→                (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5])
   328→                * q
   329→                / (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1)
   330→            )
   331→        q = math.sqrt(-2 * math.log(1 - p))
   332→        return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / (
   333→            (((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1
   334→        )
   335→
   336→    def _norm_pdf(self, x: float) -> float:
   337→        """Normal distribution probability density function.
   338→
   339→        Args:
   340→            x: Value
   341→
   342→        Returns:
   343→            PDF value
   344→        """
   345→        return math.exp(-0.5 * x * x) / math.sqrt(2 * math.pi)
   346→
   347→    def _random_uniform(self) -> float:
   348→        """Generate pseudo-random uniform number.
   349→
   350→        Simple LCG for reproducibility (not cryptographically secure).
   351→
   352→        Returns:
   353→            Random number in (0, 1)
   354→        """
   355→        import time
   356→
   357→        # Use time-based seed
   358→        seed = int(time.time() * 1000000) % (2**31)
   359→        # LCG parameters
   360→        seed = (1103515245 * seed + 12345) % (2**31)
   361→        return (seed / (2**31 - 1)) * 0.9998 + 0.0001  # Avoid exact 0 or 1
   362→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
