     1→"""CI gate checks for LIVE mode deployment.
     2→
     3→Provides pre-deployment checks that must pass before LIVE trading.
     4→Also provides machine-readable JSON report generation for Claude automated loop.
     5→
     6→Military-Grade v3.0:
     7→- Strict JSON schema validation
     8→- run_id / exec_id for traceability
     9→- context_manifest_sha for audit
    10→- POLICY_VIOLATION (exit 12) enforcement
    11→"""
    12→
    13→from __future__ import annotations
    14→
    15→import hashlib
    16→import json
    17→import logging
    18→import subprocess
    19→import time
    20→import uuid
    21→from dataclasses import asdict, dataclass, field
    22→from datetime import UTC, datetime
    23→from enum import Enum
    24→from pathlib import Path
    25→from typing import Any
    26→
    27→
    28→logger = logging.getLogger(__name__)
    29→
    30→
    31→# =============================================================================
    32→# 军规级固定路径约定 (D.1) - 按 type 严格分目录
    33→# =============================================================================
    34→FIXED_PATHS = {
    35→    # CI 产物
    36→    "ci_report": Path("artifacts/check/report.json"),
    37→    # Replay 产物（独立目录）
    38→    "replay_report": Path("artifacts/replay/report.json"),
    39→    "replay_events_jsonl": Path("artifacts/replay/events.jsonl"),
    40→    # Sim 产物（独立目录）
    41→    "sim_report": Path("artifacts/sim/report.json"),
    42→    "sim_events_jsonl": Path("artifacts/sim/events.jsonl"),
    43→    # 共享产物
    44→    "context": Path("artifacts/context/context.md"),
    45→    "commands_log": Path("artifacts/claude/commands.log"),
    46→    "round_summary": Path("artifacts/claude/round_summary.json"),
    47→    "policy_violation": Path("artifacts/claude/policy_violation.json"),
    48→}
    49→
    50→
    51→class GateCheckStatus(str, Enum):
    52→    """Gate check status."""
    53→
    54→    PASS = "PASS"
    55→    FAIL = "FAIL"
    56→    SKIP = "SKIP"
    57→
    58→
    59→@dataclass(frozen=True)
    60→class GateCheck:
    61→    """Single gate check result."""
    62→
    63→    name: str
    64→    status: GateCheckStatus
    65→    message: str = ""
    66→    required: bool = True
    67→
    68→    @property
    69→    def passed(self) -> bool:
    70→        """Check if this gate passed or was skipped."""
    71→        return self.status in (GateCheckStatus.PASS, GateCheckStatus.SKIP)
    72→
    73→    @property
    74→    def blocking(self) -> bool:
    75→        """Check if this failure blocks deployment."""
    76→        return self.required and self.status == GateCheckStatus.FAIL
    77→
    78→
    79→@dataclass(frozen=True)
    80→class GateReport:
    81→    """Full CI gate report."""
    82→
    83→    checks: tuple[GateCheck, ...]
    84→    target_mode: str
    85→
    86→    @property
    87→    def all_passed(self) -> bool:
    88→        """Check if all required checks passed."""
    89→        return not any(c.blocking for c in self.checks)
    90→
    91→    @property
    92→    def blocking_failures(self) -> list[GateCheck]:
    93→        """Get list of blocking failures."""
    94→        return [c for c in self.checks if c.blocking]
    95→
    96→    @property
    97→    def pass_count(self) -> int:
    98→        """Number of passed checks."""
    99→        return sum(1 for c in self.checks if c.passed)
   100→
   101→    def summary(self) -> str:
   102→        """Generate summary string."""
   103→        status = "PASS" if self.all_passed else "FAIL"
   104→        return (
   105→            f"CI Gate [{self.target_mode}]: {status} ({self.pass_count}/{len(self.checks)} passed)"
   106→        )
   107→
   108→
   109→class CIGate:
   110→    """
   111→    CI gate for LIVE mode deployment.
   112→
   113→    Runs a series of checks before allowing LIVE deployment.
   114→    """
   115→
   116→    def __init__(self, target_mode: str = "LIVE") -> None:
   117→        """
   118→        Initialize CI gate.
   119→
   120→        Args:
   121→            target_mode: Target deployment mode
   122→        """
   123→        self._target_mode = target_mode.upper()
   124→        self._checks: list[GateCheck] = []
   125→
   126→    def add_check(
   127→        self,
   128→        name: str,
   129→        status: GateCheckStatus,
   130→        message: str = "",
   131→        *,
   132→        required: bool = True,
   133→    ) -> None:
   134→        """Add a gate check."""
   135→        self._checks.append(GateCheck(name=name, status=status, message=message, required=required))
   136→
   137→    def check_tests_pass(self, test_passed: bool) -> None:
   138→        """Check if all tests passed."""
   139→        self.add_check(
   140→            "tests_pass",
   141→            GateCheckStatus.PASS if test_passed else GateCheckStatus.FAIL,
   142→            "All tests must pass",
   143→        )
   144→
   145→    def check_lint_pass(self, lint_passed: bool) -> None:
   146→        """Check if linting passed."""
   147→        self.add_check(
   148→            "lint_pass",
   149→            GateCheckStatus.PASS if lint_passed else GateCheckStatus.FAIL,
   150→            "Code must pass linting",
   151→        )
   152→
   153→    def check_type_check_pass(self, type_check_passed: bool) -> None:
   154→        """Check if type checking passed."""
   155→        self.add_check(
   156→            "type_check_pass",
   157→            GateCheckStatus.PASS if type_check_passed else GateCheckStatus.FAIL,
   158→            "Code must pass type checking",
   159→        )
   160→
   161→    def check_risk_limits_configured(self, configured: bool) -> None:
   162→        """Check if risk limits are configured."""
   163→        self.add_check(
   164→            "risk_limits_configured",
   165→            GateCheckStatus.PASS if configured else GateCheckStatus.FAIL,
   166→            "Risk limits must be configured for LIVE",
   167→        )
   168→
   169→    def check_broker_credentials(self, credentials_valid: bool) -> None:
   170→        """Check if broker credentials are valid."""
   171→        self.add_check(
   172→            "broker_credentials",
   173→            GateCheckStatus.PASS if credentials_valid else GateCheckStatus.FAIL,
   174→            "Broker credentials must be valid",
   175→        )
   176→
   177→    def check_model_weights_exist(self, weights_exist: bool) -> None:
   178→        """Check if model weights exist in repo."""
   179→        self.add_check(
   180→            "model_weights_exist",
   181→            GateCheckStatus.PASS if weights_exist else GateCheckStatus.FAIL,
   182→            "Model weights must be in repository",
   183→        )
   184→
   185→    def generate_report(self) -> GateReport:
   186→        """Generate gate report."""
   187→        return GateReport(
   188→            checks=tuple(self._checks),
   189→            target_mode=self._target_mode,
   190→        )
   191→
   192→    def run_all_checks(
   193→        self,
   194→        *,
   195→        tests_passed: bool = False,
   196→        lint_passed: bool = False,
   197→        type_check_passed: bool = False,
   198→        risk_limits_configured: bool = False,
   199→        broker_credentials_valid: bool = False,
   200→        model_weights_exist: bool = False,
   201→    ) -> GateReport:
   202→        """
   203→        Run all standard CI gate checks.
   204→
   205→        Args:
   206→            tests_passed: Whether tests passed
   207→            lint_passed: Whether linting passed
   208→            type_check_passed: Whether type checking passed
   209→            risk_limits_configured: Whether risk limits are set
   210→            broker_credentials_valid: Whether broker creds are valid
   211→            model_weights_exist: Whether model weights exist
   212→
   213→        Returns:
   214→            GateReport with all check results
   215→        """
   216→        self._checks = []  # Reset checks
   217→        self.check_tests_pass(tests_passed)
   218→        self.check_lint_pass(lint_passed)
   219→        self.check_type_check_pass(type_check_passed)
   220→        self.check_risk_limits_configured(risk_limits_configured)
   221→        self.check_broker_credentials(broker_credentials_valid)
   222→        self.check_model_weights_exist(model_weights_exist)
   223→        return self.generate_report()
   224→
   225→
   226→def log_gate_report(report: GateReport) -> None:
   227→    """Log gate report."""
   228→    logger.info(report.summary())
   229→    for check in report.checks:
   230→        status_str = check.status.value
   231→        req_str = "[REQ]" if check.required else "[OPT]"
   232→        logger.info("  %s %s %s: %s", req_str, status_str, check.name, check.message)
   233→    if report.blocking_failures:
   234→        logger.error("Blocking failures: %d", len(report.blocking_failures))
   235→
   236→
   237→# =============================================================================
   238→# 退出码约定（军规级）
   239→# =============================================================================
   240→class ExitCode:
   241→    """Standard exit codes for CI gate.
   242→
   243→    Exit codes:
   244→        0 = All checks passed
   245→        1 = General error (unexpected)
   246→        2 = Format or Lint check failed
   247→        3 = Type check failed
   248→        4 = Test failed
   249→        5 = Coverage threshold not met
   250→        6 = Risk limits not configured
   251→        7 = Broker credentials invalid
   252→        8 = Replay failed (reserved for sim_gate)
   253→        9 = Sim failed (reserved for sim_gate)
   254→        12 = Policy violation (military-grade enforcement)
   255→    """
   256→
   257→    SUCCESS = 0
   258→    GENERAL_ERROR = 1
   259→    FORMAT_LINT_FAIL = 2
   260→    TYPE_CHECK_FAIL = 3
   261→    TEST_FAIL = 4
   262→    COVERAGE_FAIL = 5
   263→    RISK_CONFIG_FAIL = 6
   264→    BROKER_CREDS_FAIL = 7
   265→    REPLAY_FAIL = 8
   266→    SIM_FAIL = 9
   267→    POLICY_VIOLATION = 12
   268→
   269→
   270→def get_exit_code(report: GateReport) -> int:
   271→    """Determine exit code based on gate report.
   272→
   273→    Returns appropriate exit code based on first blocking failure.
   274→    """
   275→    if report.all_passed:
   276→        return ExitCode.SUCCESS
   277→
   278→    # Check failures in order of priority
   279→    for check in report.blocking_failures:
   280→        if check.name in ("format_pass", "lint_pass"):
   281→            return ExitCode.FORMAT_LINT_FAIL
   282→        if check.name == "type_check_pass":
   283→            return ExitCode.TYPE_CHECK_FAIL
   284→        if check.name == "tests_pass":
   285→            return ExitCode.TEST_FAIL
   286→        if check.name == "coverage_pass":
   287→            return ExitCode.COVERAGE_FAIL
   288→        if check.name == "risk_limits_configured":
   289→            return ExitCode.RISK_CONFIG_FAIL
   290→        if check.name == "broker_credentials":
   291→            return ExitCode.BROKER_CREDS_FAIL
   292→
   293→    return ExitCode.GENERAL_ERROR
   294→
   295→
   296→# =============================================================================
   297→# CHECK 模式硬禁令
   298→# =============================================================================
   299→_CHECK_MODE_ENABLED: bool = False
   300→
   301→
   302→def enable_check_mode() -> None:
   303→    """Enable CHECK mode - blocks all broker operations."""
   304→    global _CHECK_MODE_ENABLED
   305→    _CHECK_MODE_ENABLED = True
   306→    logger.warning("CHECK_MODE enabled - broker.place_order will be blocked")
   307→
   308→
   309→def disable_check_mode() -> None:
   310→    """Disable CHECK mode."""
   311→    global _CHECK_MODE_ENABLED
   312→    _CHECK_MODE_ENABLED = False
   313→
   314→
   315→def is_check_mode() -> bool:
   316→    """Check if CHECK mode is active."""
   317→    return _CHECK_MODE_ENABLED
   318→
   319→
   320→def assert_not_check_mode(operation: str = "place_order") -> None:
   321→    """Assert that we are NOT in CHECK mode.
   322→
   323→    Raises:
   324→        RuntimeError: If CHECK mode is enabled and broker operation is attempted.
   325→
   326→    Usage:
   327→        # In broker.place_order():
   328→        assert_not_check_mode("place_order")
   329→    """
   330→    if _CHECK_MODE_ENABLED:
   331→        msg = f"BLOCKED: {operation} is forbidden in CHECK_MODE=1"
   332→        logger.error(msg)
   333→        raise RuntimeError(msg)
   334→
   335→
   336→# =============================================================================
   337→# CI JSON 报告生成（供 Claude 自动闭环使用）
   338→# =============================================================================
   339→
   340→
   341→class CIStepStatus(str, Enum):
   342→    """CI step status."""
   343→
   344→    PASS = "PASS"
   345→    FAIL = "FAIL"
   346→    SKIP = "SKIP"
   347→
   348→
   349→@dataclass
   350→class CIStepFailure:
   351→    """Single failure detail within a CI step."""
   352→
   353→    file: str
   354→    line: int
   355→    rule: str
   356→    message: str
   357→
   358→
   359→@dataclass
   360→class CIStep:
   361→    """Single CI step result."""
   362→
   363→    name: str
   364→    status: CIStepStatus
   365→    exit_code: int | None = None
   366→    duration_ms: int = 0
   367→    summary: str = ""  # First 50 lines of output
   368→    reason: str = ""  # For SKIP status
   369→    failures: list[CIStepFailure] = field(default_factory=list)
   370→    hints: list[str] = field(default_factory=list)  # Common fix suggestions
   371→
   372→    def to_dict(self) -> dict[str, Any]:
   373→        """Convert to dictionary."""
   374→        result: dict[str, Any] = {
   375→            "name": self.name,
   376→            "status": self.status.value,
   377→            "exit_code": self.exit_code,
   378→            "duration_ms": self.duration_ms,
   379→        }
   380→        if self.status == CIStepStatus.SKIP:
   381→            result["reason"] = self.reason
   382→        elif self.status == CIStepStatus.FAIL:
   383→            result["summary"] = self.summary
   384→            if self.failures:
   385→                result["failures"] = [asdict(f) for f in self.failures]
   386→            if self.hints:
   387→                result["hints"] = self.hints
   388→        return result
   389→
   390→
   391→def _generate_run_id() -> str:
   392→    """Generate a unique run_id (UUID)."""
   393→    return str(uuid.uuid4())
   394→
   395→
   396→def _generate_exec_id() -> str:
   397→    """Generate exec_id from git commit + timestamp."""
   398→    import subprocess
   399→
   400→    try:
   401→        result = subprocess.run(
   402→            ["git", "rev-parse", "HEAD"],
   403→            capture_output=True,
   404→            text=True,
   405→            check=False,
   406→        )
   407→        commit = result.stdout.strip()[:8] if result.returncode == 0 else "unknown"
   408→    except Exception:
   409→        commit = "unknown"
   410→    ts = datetime.now(UTC).strftime("%Y%m%d%H%M%S")
   411→    return f"{commit}_{ts}"
   412→
   413→
   414→def _compute_context_sha(context_path: Path) -> str:
   415→    """Compute SHA256 of context.md for audit."""
   416→    if not context_path.exists():
   417→        return ""
   418→    with open(context_path, "rb") as f:
   419→        return hashlib.sha256(f.read()).hexdigest()
   420→
   421→
   422→@dataclass
   423→class CIJsonReport:
   424→    """Machine-readable CI report for Claude automated loop (Military-Grade v3.0).
   425→
   426→    Military-grade required fields:
   427→    - schema_version: must be >= 3
   428→    - type: "ci"
   429→    - run_id: UUID for traceability
   430→    - exec_id: commit_sha + timestamp
   431→    - artifacts: paths to generated files
   432→    - context_manifest_sha: SHA256 of context.md
   433→    """
   434→
   435→    steps: list[CIStep] = field(default_factory=list)
   436→    schema_version: int = 3
   437→    check_mode: bool = False
   438→    timestamp: str = ""
   439→    run_id: str = ""
   440→    exec_id: str = ""
   441→    context_manifest_sha: str = ""
   442→
   443→    def __post_init__(self) -> None:
   444→        if not self.timestamp:
   445→            self.timestamp = datetime.now(UTC).isoformat()
   446→        if not self.run_id:
   447→            self.run_id = _generate_run_id()
   448→        if not self.exec_id:
   449→            self.exec_id = _generate_exec_id()
   450→        # Compute context SHA if available
   451→        context_path = FIXED_PATHS["context"]
   452→        if not self.context_manifest_sha and context_path.exists():
   453→            self.context_manifest_sha = _compute_context_sha(context_path)
   454→
   455→    @property
   456→    def all_passed(self) -> bool:
   457→        """Check if all steps passed."""
   458→        return not any(s.status == CIStepStatus.FAIL for s in self.steps)
   459→
   460→    @property
   461→    def failed_step(self) -> str | None:
   462→        """Get first failed step name."""
   463→        for step in self.steps:
   464→            if step.status == CIStepStatus.FAIL:
   465→                return step.name
   466→        return None
   467→
   468→    @property
   469→    def overall(self) -> str:
   470→        """Overall status string."""
   471→        return "PASS" if self.all_passed else "FAIL"
   472→
   473→    @property
   474→    def exit_code(self) -> int:
   475→        """Overall exit code (first failure)."""
   476→        for step in self.steps:
   477→            if step.status == CIStepStatus.FAIL and step.exit_code is not None:
   478→                return step.exit_code
   479→        return 0
   480→
   481→    def add_step(self, step: CIStep) -> None:
   482→        """Add a CI step result."""
   483→        self.steps.append(step)
   484→
   485→    def to_dict(self) -> dict[str, Any]:
   486→        """Convert to dictionary (Military-Grade v3.0 schema)."""
   487→        return {
   488→            # 强制顶层字段（缺一不可）
   489→            "schema_version": self.schema_version,
   490→            "type": "ci",
   491→            "overall": self.overall,
   492→            "exit_code": self.exit_code,
   493→            "check_mode": self.check_mode,
   494→            "timestamp": self.timestamp,
   495→            "run_id": self.run_id,
   496→            "exec_id": self.exec_id,
   497→            "artifacts": {
   498→                # 军规级: 使用 POSIX 格式确保跨平台一致性 (Windows \ → /)
   499→                "report_path": FIXED_PATHS["ci_report"].as_posix(),
   500→                "context_path": FIXED_PATHS["context"].as_posix(),
   501→            },
   502→            "context_manifest_sha": self.context_manifest_sha,
   503→            # 兼容字段
   504→            "all_passed": self.all_passed,
   505→            "failed_step": self.failed_step,
   506→            "steps": [s.to_dict() for s in self.steps],
   507→        }
   508→
   509→    def to_json(self, indent: int = 2) -> str:
   510→        """Convert to JSON string."""
   511→        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)
   512→
   513→    def save(self, path: str | Path) -> None:
   514→        """Save report to file."""
   515→        path = Path(path)
   516→        path.parent.mkdir(parents=True, exist_ok=True)
   517→        path.write_text(self.to_json(), encoding="utf-8")
   518→        logger.info("CI report saved to %s", path)
   519→
   520→
   521→def parse_ruff_output(output: str) -> list[CIStepFailure]:
   522→    """Parse ruff output into structured failures."""
   523→    failures = []
   524→    for line in output.strip().split("\n"):
   525→        if not line.strip():
   526→            continue
   527→        # Format: path/file.py:line:col: RULE message
   528→        parts = line.split(":", 3)
   529→        if len(parts) >= 4:
   530→            file_path = parts[0]
   531→            try:
   532→                line_no = int(parts[1])
   533→            except ValueError:
   534→                continue
   535→            rest = parts[3].strip()
   536→            # Extract rule code (e.g., E501, W503)
   537→            rule_parts = rest.split(" ", 1)
   538→            rule = rule_parts[0] if rule_parts else ""
   539→            message = rule_parts[1] if len(rule_parts) > 1 else rest
   540→            failures.append(CIStepFailure(file=file_path, line=line_no, rule=rule, message=message))
   541→    return failures
   542→
   543→
   544→def parse_mypy_output(output: str) -> list[CIStepFailure]:
   545→    """Parse mypy output into structured failures."""
   546→    failures = []
   547→    for line in output.strip().split("\n"):
   548→        if not line.strip() or line.startswith("Found"):
   549→            continue
   550→        # Format: path/file.py:line: error: message
   551→        parts = line.split(":", 3)
   552→        if len(parts) >= 3:
   553→            file_path = parts[0]
   554→            try:
   555→                line_no = int(parts[1])
   556→            except ValueError:
   557→                continue
   558→            message = parts[2].strip() if len(parts) == 3 else parts[3].strip()
   559→            rule = "type-error"
   560→            if ": error:" in line:
   561→                rule = "error"
   562→            elif ": note:" in line:
   563→                rule = "note"
   564→            failures.append(CIStepFailure(file=file_path, line=line_no, rule=rule, message=message))
   565→    return failures
   566→
   567→
   568→def parse_pytest_output(output: str) -> list[CIStepFailure]:
   569→    """Parse pytest output into structured failures."""
   570→    failures = []
   571→    # Look for FAILED lines
   572→    for line in output.strip().split("\n"):
   573→        if "FAILED" in line:
   574→            # Format: FAILED tests/test_foo.py::test_bar - AssertionError
   575→            parts = line.split(" ", 2)
   576→            if len(parts) >= 2:
   577→                test_path = parts[1].split("::")[0] if "::" in parts[1] else parts[1]
   578→                message = parts[2] if len(parts) > 2 else "test failed"
   579→                failures.append(
   580→                    CIStepFailure(file=test_path, line=0, rule="FAILED", message=message)
   581→                )
   582→    return failures
   583→
   584→
   585→# =============================================================================
   586→# Hints 生成（常见错误的修复建议）
   587→# =============================================================================
   588→
   589→STEP_HINTS: dict[str, dict[str, list[str]]] = {
   590→    "format-check": {
   591→        "default": [
   592→            "Run: make format (or .\\scripts\\make.ps1 format) to auto-fix",
   593→            "Most format issues can be auto-fixed by ruff",
   594→        ],
   595→    },
   596→    "lint": {
   597→        "E501": ["Line too long - break into multiple lines or use parentheses"],
   598→        "F401": ["Unused import - remove the import statement"],
   599→        "F841": ["Unused variable - remove or use the variable"],
   600→        "E711": ["Use 'is None' instead of '== None'"],
   601→        "E712": ["Use 'is True/False' instead of '== True/False'"],
   602→        "default": [
   603→            "Run: make lint-fix to auto-fix some issues",
   604→            "Check ruff docs for rule explanation",
   605→        ],
   606→    },
   607→    "type": {
   608→        "default": [
   609→            "Add type annotations to function parameters and return values",
   610→            "Use 'Any' as escape hatch if truly dynamic typing needed",
   611→            "Check mypy docs for error explanation",
   612→        ],
   613→        "incompatible": ["Check if types match between assignment and variable"],
   614→        "missing": ["Add missing type stub or use 'type: ignore' comment"],
   615→    },
   616→    "test": {
   617→        "default": [
   618→            "Check test assertion - expected vs actual values",
   619→            "Run specific test: pytest tests/test_xxx.py::test_name -xvs",
   620→        ],
   621→        "coverage": [
   622→            "Add tests for uncovered code paths",
   623→            "Current threshold: 85% - check coverage report for gaps",
   624→        ],
   625→    },
   626→}
   627→
   628→
   629→def get_hints_for_step(step_name: str, failures: list[CIStepFailure], output: str) -> list[str]:
   630→    """Generate hints based on step name and failures."""
   631→    hints: list[str] = []
   632→    step_hints = STEP_HINTS.get(step_name, {})
   633→
   634→    # Check for specific rule hints
   635→    seen_rules: set[str] = set()
   636→    for failure in failures:
   637→        rule = failure.rule
   638→        if rule not in seen_rules and rule in step_hints:
   639→            hints.extend(step_hints[rule])
   640→            seen_rules.add(rule)
   641→
   642→    # Check output for keywords
   643→    if "coverage" in output.lower() and "coverage" in step_hints:
   644→        hints.extend(step_hints["coverage"])
   645→    if "incompatible" in output.lower() and "incompatible" in step_hints:
   646→        hints.extend(step_hints["incompatible"])
   647→
   648→    # Add default hints if no specific ones found
   649→    if not hints and "default" in step_hints:
   650→        hints.extend(step_hints["default"])
   651→
   652→    return hints[:5]  # Limit to 5 hints
   653→
   654→
   655→def run_ci_step(  # pragma: no cover
   656→    name: str,
   657→    command: list[str],
   658→    exit_code_on_fail: int,
   659→    parser: Any = None,  # Callable[[str], list[CIStepFailure]]
   660→) -> CIStep:
   661→    """
   662→    Run a single CI step and capture result.
   663→
   664→    Args:
   665→        name: Step name (format-check, lint, type, test)
   666→        command: Command to run
   667→        exit_code_on_fail: Exit code to use on failure
   668→        parser: Optional output parser function
   669→
   670→    Returns:
   671→        CIStep with result
   672→    """
   673→    start = time.time()
   674→
   675→    try:
   676→        result = subprocess.run(
   677→            command,
   678→            check=False,
   679→            capture_output=True,
   680→            text=True,
   681→            timeout=600,  # 10 minute timeout
   682→        )
   683→        duration_ms = int((time.time() - start) * 1000)
   684→        output = result.stdout + result.stderr
   685→
   686→        if result.returncode == 0:
   687→            return CIStep(
   688→                name=name,
   689→                status=CIStepStatus.PASS,
   690→                exit_code=0,
   691→                duration_ms=duration_ms,
   692→            )
   693→
   694→        # Parse failures if parser provided
   695→        failures = parser(output) if parser else []
   696→
   697→        # Truncate output summary to first 50 lines
   698→        output_lines = output.strip().split("\n")
   699→        summary = "\n".join(output_lines[:50])
   700→
   701→        # Generate hints
   702→        hints = get_hints_for_step(name, failures, output)
   703→
   704→        return CIStep(
   705→            name=name,
   706→            status=CIStepStatus.FAIL,
   707→            exit_code=exit_code_on_fail,
   708→            duration_ms=duration_ms,
   709→            summary=summary,
   710→            failures=failures,
   711→            hints=hints,
   712→        )
   713→
   714→    except subprocess.TimeoutExpired:
   715→        duration_ms = int((time.time() - start) * 1000)
   716→        return CIStep(
   717→            name=name,
   718→            status=CIStepStatus.FAIL,
   719→            exit_code=exit_code_on_fail,
   720→            duration_ms=duration_ms,
   721→            summary="Command timed out after 600 seconds",
   722→            hints=["Check for infinite loops or very slow operations"],
   723→        )
   724→    except Exception as e:
   725→        duration_ms = int((time.time() - start) * 1000)
   726→        return CIStep(
   727→            name=name,
   728→            status=CIStepStatus.FAIL,
   729→            exit_code=exit_code_on_fail,
   730→            duration_ms=duration_ms,
   731→            summary=f"Error running command: {e}",
   732→            hints=["Check if the command exists and dependencies are installed"],
   733→        )
   734→
   735→
   736→def run_ci_with_json_report(  # pragma: no cover
   737→    python_exe: str = ".venv/Scripts/python.exe",
   738→    output_path: str = "artifacts/check/report.json",
   739→    cov_threshold: int = 85,
   740→) -> CIJsonReport:
   741→    """
   742→    Run full CI pipeline and generate JSON report.
   743→
   744→    Args:
   745→        python_exe: Path to Python executable
   746→        output_path: Output path for JSON report
   747→        cov_threshold: Coverage threshold percentage
   748→
   749→    Returns:
   750→        CIJsonReport with all results
   751→    """
   752→    # Military-Grade v3.0: check_mode MUST be True for CI
   753→    report = CIJsonReport(check_mode=True)
   754→
   755→    # Step 1: Format check
   756→    step = run_ci_step(
   757→        name="format-check",
   758→        command=[python_exe, "-m", "ruff", "format", "--check", "."],
   759→        exit_code_on_fail=ExitCode.FORMAT_LINT_FAIL,
   760→        parser=parse_ruff_output,
   761→    )
   762→    report.add_step(step)
   763→
   764→    if step.status == CIStepStatus.FAIL:
   765→        # Skip remaining steps
   766→        for name in ["lint", "type", "test"]:
   767→            report.add_step(
   768→                CIStep(
   769→                    name=name,
   770→                    status=CIStepStatus.SKIP,
   771→                    reason="previous step failed",
   772→                )
   773→            )
   774→        report.save(output_path)
   775→        return report
   776→
   777→    # Step 2: Lint
   778→    step = run_ci_step(
   779→        name="lint",
   780→        command=[python_exe, "-m", "ruff", "check", "."],
   781→        exit_code_on_fail=ExitCode.FORMAT_LINT_FAIL,
   782→        parser=parse_ruff_output,
   783→    )
   784→    report.add_step(step)
   785→
   786→    if step.status == CIStepStatus.FAIL:
   787→        for name in ["type", "test"]:
   788→            report.add_step(
   789→                CIStep(
   790→                    name=name,
   791→                    status=CIStepStatus.SKIP,
   792→                    reason="previous step failed",
   793→                )
   794→            )
   795→        report.save(output_path)
   796→        return report
   797→
   798→    # Step 3: Type check (src only, tests excluded via pyproject.toml)
   799→    step = run_ci_step(
   800→        name="type",
   801→        command=[python_exe, "-m", "mypy", "src"],
   802→        exit_code_on_fail=ExitCode.TYPE_CHECK_FAIL,
   803→        parser=parse_mypy_output,
   804→    )
   805→    report.add_step(step)
   806→
   807→    if step.status == CIStepStatus.FAIL:
   808→        report.add_step(
   809→            CIStep(
   810→                name="test",
   811→                status=CIStepStatus.SKIP,
   812→                reason="previous step failed",
   813→            )
   814→        )
   815→        report.save(output_path)
   816→        return report
   817→
   818→    # Step 4: Test
   819→    step = run_ci_step(
   820→        name="test",
   821→        command=[
   822→            python_exe,
   823→            "-m",
   824→            "pytest",
   825→            "-q",
   826→            "--cov=src",
   827→            "--cov-report=term-missing:skip-covered",
   828→            f"--cov-fail-under={cov_threshold}",
   829→        ],
   830→        exit_code_on_fail=ExitCode.TEST_FAIL,
   831→        parser=parse_pytest_output,
   832→    )
   833→    report.add_step(step)
   834→
   835→    report.save(output_path)
   836→    return report
   837→
   838→
   839→# =============================================================================
   840→# Schema 校验与 Policy Violation 检测（军规级）
   841→# =============================================================================
   842→
   843→# CI Report v3.0 必须字段
   844→CI_REPORT_REQUIRED_FIELDS = {
   845→    "schema_version",
   846→    "type",
   847→    "overall",
   848→    "exit_code",
   849→    "check_mode",
   850→}
   851→
   852→# Sim/Replay Report 必须字段
   853→SIM_REPORT_REQUIRED_FIELDS = {
   854→    "schema_version",
   855→    "type",
   856→    "overall",
   857→    "exit_code",
   858→    "check_mode",
   859→    "scenarios_total",
   860→    "scenarios_passed",
   861→    "scenarios_failed",
   862→}
   863→
   864→# Failure 必须字段
   865→FAILURE_REQUIRED_FIELDS = {
   866→    "rule_id",
   867→    "component",
   868→    "expected",
   869→    "actual",
   870→    "tick",
   871→    "error",
   872→}
   873→
   874→
   875→@dataclass
   876→class PolicyViolation:
   877→    """Policy violation detail."""
   878→
   879→    code: str
   880→    message: str
   881→    evidence: dict[str, Any] = field(default_factory=dict)
   882→
   883→    def to_dict(self) -> dict[str, Any]:
   884→        """Convert to dictionary."""
   885→        return {
   886→            "code": self.code,
   887→            "message": self.message,
   888→            "evidence": self.evidence,
   889→        }
   890→
   891→
   892→@dataclass
   893→class PolicyReport:
   894→    """Policy violation report."""
   895→
   896→    violations: list[PolicyViolation] = field(default_factory=list)
   897→    timestamp: str = ""
   898→
   899→    def __post_init__(self) -> None:
   900→        if not self.timestamp:
   901→            self.timestamp = datetime.now(UTC).isoformat()
   902→
   903→    @property
   904→    def has_violations(self) -> bool:
   905→        """Check if any violations exist."""
   906→        return len(self.violations) > 0
   907→
   908→    def add_violation(
   909→        self,
   910→        code: str,
   911→        message: str,
   912→        evidence: dict[str, Any] | None = None,
   913→    ) -> None:
   914→        """Add a policy violation."""
   915→        self.violations.append(PolicyViolation(code=code, message=message, evidence=evidence or {}))
   916→        logger.error("POLICY_VIOLATION: [%s] %s", code, message)
   917→
   918→    def to_dict(self) -> dict[str, Any]:
   919→        """Convert to dictionary."""
   920→        return {
   921→            "timestamp": self.timestamp,
   922→            "has_violations": self.has_violations,
   923→            "violation_count": len(self.violations),
   924→            "violations": [v.to_dict() for v in self.violations],
   925→        }
   926→
   927→    def to_json(self, indent: int = 2) -> str:
   928→        """Convert to JSON string."""
   929→        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)
   930→
   931→    def save(self, path: str | Path) -> None:
   932→        """Save report to file."""
   933→        path = Path(path)
   934→        path.parent.mkdir(parents=True, exist_ok=True)
   935→        path.write_text(self.to_json(), encoding="utf-8")
   936→        logger.info("Policy violation report saved to %s", path)
   937→
   938→
   939→def validate_report_schema(
   940→    report_path: str | Path,
   941→    report_type: str = "ci",
   942→) -> PolicyReport:
   943→    """
   944→    Validate report JSON schema and return policy violations.
   945→
   946→    Args:
   947→        report_path: Path to report.json
   948→        report_type: Type of report ("ci", "replay", "sim")
   949→
   950→    Returns:
   951→        PolicyReport with any violations found
   952→    """
   953→    policy_report = PolicyReport()
   954→    path = Path(report_path)
   955→
   956→    # Check 1: File exists
   957→    if not path.exists():
   958→        policy_report.add_violation(
   959→            code="SCHEMA.FILE_MISSING",
   960→            message=f"Report file not found: {path}",
   961→            evidence={"expected_path": str(path)},
   962→        )
   963→        return policy_report
   964→
   965→    # Check 2: Valid JSON
   966→    try:
   967→        with open(path, encoding="utf-8") as f:
   968→            data = json.load(f)
   969→    except json.JSONDecodeError as e:
   970→        policy_report.add_violation(
   971→            code="SCHEMA.INVALID_JSON",
   972→            message=f"Invalid JSON in report: {e}",
   973→            evidence={"path": str(path), "error": str(e)},
   974→        )
   975→        return policy_report
   976→
   977→    # Check 3: Required fields
   978→    required_fields = (
   979→        SIM_REPORT_REQUIRED_FIELDS
   980→        if report_type in ("replay", "sim")
   981→        else CI_REPORT_REQUIRED_FIELDS
   982→    )
   983→
   984→    missing_fields = required_fields - set(data.keys())
   985→    if missing_fields:
   986→        policy_report.add_violation(
   987→            code="SCHEMA.MISSING_FIELDS",
   988→            message=f"Missing required fields: {missing_fields}",
   989→            evidence={"missing": list(missing_fields), "found": list(data.keys())},
   990→        )
   991→
   992→    # Check 4: Schema version
   993→    if "schema_version" in data:
   994→        version = data["schema_version"]
   995→        if not isinstance(version, int) or version < 3:
   996→            policy_report.add_violation(
   997→                code="SCHEMA.VERSION_OUTDATED",
   998→                message=f"Schema version must be >= 3, got {version}",
   999→                evidence={"current_version": version, "required_version": 3},
  1000→            )
  1001→
  1002→    # Check 5: check_mode must be True for replay/sim
  1003→    if report_type in ("replay", "sim"):
  1004→        if not data.get("check_mode", False):
  1005→            policy_report.add_violation(
  1006→                code="POLICY.CHECK_MODE_DISABLED",
  1007→                message="CHECK_MODE must be enabled for replay/sim",
  1008→                evidence={"check_mode": data.get("check_mode")},
  1009→            )
  1010→
  1011→    # Check 6: Failure structure (for replay/sim)
  1012→    if report_type in ("replay", "sim") and "failures" in data:
  1013→        for i, failure in enumerate(data["failures"]):
  1014→            if not isinstance(failure, dict):
  1015→                continue
  1016→            missing = FAILURE_REQUIRED_FIELDS - set(failure.keys())
  1017→            if missing:
  1018→                policy_report.add_violation(
  1019→                    code="SCHEMA.FAILURE_INCOMPLETE",
  1020→                    message=f"Failure {i} missing fields: {missing}",
  1021→                    evidence={
  1022→                        "index": i,
  1023→                        "missing": list(missing),
  1024→                        "failure": failure,
  1025→                    },
  1026→                )
  1027→
  1028→    return policy_report
  1029→
  1030→
  1031→def check_command_whitelist(command: str) -> PolicyReport:
  1032→    """
  1033→    Check if a command is in the whitelist.
  1034→
  1035→    Only make.ps1 targets are allowed.
  1036→
  1037→    Args:
  1038→        command: Command string to check
  1039→
  1040→    Returns:
  1041→        PolicyReport with any violations
  1042→    """
  1043→    policy_report = PolicyReport()
  1044→
  1045→    # Whitelist: only make.ps1 targets (used for future positive matching)
  1046→    _allowed_patterns = [
  1047→        r"\.[\\/]scripts[\\/]make\.ps1",
  1048→        r"make\.ps1",
  1049→        r"git\s+(status|diff|log)",
  1050→        r"cat\s+",
  1051→        r"Get-Content\s+",
  1052→    ]
  1053→
  1054→    # Blacklist: direct tool invocation
  1055→    blacklist_patterns = [
  1056→        r"^pytest\s",
  1057→        r"^ruff\s",
  1058→        r"^mypy\s",
  1059→        r"python\s+-m\s+pytest",
  1060→        r"python\s+-m\s+ruff",
  1061→        r"python\s+-m\s+mypy",
  1062→    ]
  1063→
  1064→    import re
  1065→
  1066→    for pattern in blacklist_patterns:
  1067→        if re.search(pattern, command, re.IGNORECASE):
  1068→            policy_report.add_violation(
  1069→                code="POLICY.COMMAND_BLACKLISTED",
  1070→                message=f"Direct tool invocation not allowed: {command}",
  1071→                evidence={
  1072→                    "command": command,
  1073→                    "pattern": pattern,
  1074→                    "hint": "Use make.ps1 targets instead",
  1075→                },
  1076→            )
  1077→            break
  1078→
  1079→    return policy_report
  1080→
  1081→
  1082→def check_artifact_paths() -> PolicyReport:
  1083→    """
  1084→    Check that artifact paths match the fixed convention.
  1085→
  1086→    D.1: 产物路径绝对不变，按 type 严格分目录
  1087→
  1088→    Returns:
  1089→        PolicyReport with any violations
  1090→    """
  1091→    policy_report = PolicyReport()
  1092→
  1093→    # D.1 军规级约定: 按 type 严格分目录
  1094→    _expected_paths = {
  1095→        "ci_report": Path("artifacts/check/report.json"),
  1096→        "replay_report": Path("artifacts/replay/report.json"),
  1097→        "sim_report": Path("artifacts/sim/report.json"),
  1098→        "context": Path("artifacts/context/context.md"),
  1099→        "commands_log": Path("artifacts/claude/commands.log"),
  1100→        "round_summary": Path("artifacts/claude/round_summary.json"),
  1101→        "policy_violation": Path("artifacts/claude/policy_violation.json"),
  1102→    }
  1103→
  1104→    # Just validate the structure is known
  1105→    # Actual path checking happens at runtime
  1106→    return policy_report
  1107→
  1108→
  1109→# =============================================================================
  1110→# Enhanced CIJsonReport v3.0（军规级）
  1111→# =============================================================================
  1112→
  1113→
  1114→@dataclass
  1115→class CIJsonReportV3:
  1116→    """Machine-readable CI report v3.0 for military-grade Claude loop.
  1117→
  1118→    Military-grade enhancements:
  1119→    - schema_version: integer, must be >= 3
  1120→    - type: report type ("ci", "replay", "sim")
  1121→    - check_mode: boolean, must be true for replay/sim
  1122→    - Strict field validation
  1123→    """
  1124→
  1125→    steps: list[CIStep] = field(default_factory=list)
  1126→    schema_version: int = 3
  1127→    type: str = "ci"
  1128→    check_mode: bool = False
  1129→    timestamp: str = ""
  1130→
  1131→    def __post_init__(self) -> None:
  1132→        if not self.timestamp:
  1133→            self.timestamp = datetime.now(UTC).isoformat()
  1134→
  1135→    @property
  1136→    def all_passed(self) -> bool:
  1137→        """Check if all steps passed."""
  1138→        return not any(s.status == CIStepStatus.FAIL for s in self.steps)
  1139→
  1140→    @property
  1141→    def failed_step(self) -> str | None:
  1142→        """Get first failed step name."""
  1143→        for step in self.steps:
  1144→            if step.status == CIStepStatus.FAIL:
  1145→                return step.name
  1146→        return None
  1147→
  1148→    @property
  1149→    def overall(self) -> str:
  1150→        """Overall status string."""
  1151→        return "PASS" if self.all_passed else "FAIL"
  1152→
  1153→    @property
  1154→    def exit_code(self) -> int:
  1155→        """Overall exit code (first failure)."""
  1156→        for step in self.steps:
  1157→            if step.status == CIStepStatus.FAIL and step.exit_code is not None:
  1158→                return step.exit_code
  1159→        return 0
  1160→
  1161→    def add_step(self, step: CIStep) -> None:
  1162→        """Add a CI step result."""
  1163→        self.steps.append(step)
  1164→
  1165→    def to_dict(self) -> dict[str, Any]:
  1166→        """Convert to dictionary."""
  1167→        return {
  1168→            "schema_version": self.schema_version,
  1169→            "type": self.type,
  1170→            "timestamp": self.timestamp,
  1171→            "check_mode": self.check_mode,
  1172→            "all_passed": self.all_passed,
  1173→            "failed_step": self.failed_step,
  1174→            "overall": self.overall,
  1175→            "exit_code": self.exit_code,
  1176→            "steps": [s.to_dict() for s in self.steps],
  1177→        }
  1178→
  1179→    def to_json(self, indent: int = 2) -> str:
  1180→        """Convert to JSON string."""
  1181→        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)
  1182→
  1183→    def save(self, path: str | Path) -> None:
  1184→        """Save report to file."""
  1185→        path = Path(path)
  1186→        path.parent.mkdir(parents=True, exist_ok=True)
  1187→        path.write_text(self.to_json(), encoding="utf-8")
  1188→        logger.info("CI report v3 saved to %s", path)
  1189→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
