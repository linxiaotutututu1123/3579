# V4PRO 框架的架构、设计原则与绝对规则

本文件会在会话启动时由 Claude Code 读取，以确保开发工作始终符合项目标准，产出一致且高质量的成果。

🎯 项目目标

看 行为准则.md 文件。
详细看 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 文件。

💡 核心使命 (详细看 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 文件)
通过以下能力提升人工智能辅助开发的效率与可靠性：
执行前置信度校验（避免开发方向偏差）
智能拆解任务（自动识别子任务）
自动生成代码（提高开发速度）
智能提示与补全（减少手动输入）
实施后效果验证（杜绝生成内容失真）
跨会话学习（基于反思模式）
高令牌效率的并行执行（提速 3.5 倍）
持续迭代更新（支持增量式升级））

所有的的步骤都要满足以下所有的军规：必须遵守军规 M1-M33。（每一个代码都要满足M1到M33的要求）每一个代码都要M1到M33都要满足）每写完一个代码模块都要检查是否满足军规 M1-M33。
1.2 军规总表 M1-M33

| 编号 | 军规名称 | 原则描述 | 违规后果 | 检查方式 |
|------|----------|----------|----------|----------|
| **M1** | 单一信号源 | 一个交易信号只能来自一个策略实例 | 订单冲突、重复下单 | 代码审查 + 单测 |
| **M2** | 幂等执行 | 相同信号重复执行结果一致 | 重复下单、资金损失 | 回放测试 |
| **M3** | 完整审计 | 所有决策必须有审计日志 | 无法追溯、监管风险 | 日志检查 |
| **M4** | 降级兜底 | 策略异常必须有降级路径 | 系统瘫痪、无法交易 | 异常注入测试 |
| **M5** | 成本先行 | 信号边际收益必须大于成本 | 亏损交易、无效下单 | 成本门禁 |
| **M6** | 熔断保护 | 触发风控阈值必须立即停止 | 巨额亏损、穿仓 | 风控测试 |
| **M7** | 回放一致 | 相同输入必须产生相同输出 | 无法验证、策略失效 | 回放测试 |
| **M8** | 配置隔离 | 不同环境配置严格隔离 | 误操作、资金损失 | 配置审查 |
| **M9** | 错误上报 | 所有异常必须上报监控系统 | 故障隐藏、延误处理 | 告警测试 |
| **M10** | 资源限制 | CPU/内存/网络必须有上限 | 系统崩溃、影响其他服务 | 压测 |
| **M11** | 版本兼容 | 新版本必须兼容旧数据格式 | 数据丢失、回滚困难 | 兼容性测试 |
| **M12** | 双重确认 | 大额订单需人工或二次确认 | 误操作、巨额损失 | 流程审查 |
| **M13** | 涨跌停感知 | 订单价格必须检查涨跌停板 | 废单、无效挂单 | 行情检查 |
| **M14** | 平今平昨分离 | 平仓时必须区分平今/平昨 | 手续费计算错误 | 持仓检查 |
| **M15** | 夜盘跨日处理 | 夜盘交易日归属必须正确 | 结算错误、持仓混乱 | 日历检查 |
| **M16** | 保证金实时监控 | 保证金使用率必须实时计算 | 强平风险、穿仓 | 风控检查 |
| **M17** | 程序化合规 | 报撤单频率必须在监管阈值内 | 监管处罚、限制交易 | 合规检查 |
| **M18** | 实验性门禁 | 未成熟策略禁止实盘启用 | 策略失效、资金损失 | 成熟度检查 |
| **M19** | 风险归因 | 每笔亏损必须有归因分析 | 无法改进、重复犯错 | 归因报告 |
| **M20** | 跨所一致 | 不同交易所逻辑必须一致 | 套利失败、对冲失效 | 跨所测试 |
| **M21** | Git Workflow | 规范化分支与提交 | 代码混乱、难以追踪 | 阅读1.2.1 |
| **M22** | 文档齐全 | 所有公共API必须有文档 | 难以维护、使用错误 | TASK.md, KNOWLEDGE.md, PLANNING.md, 所有docs文件夹的文件 |
| **M23** | 版本管理 | 版本号必须同步更新 | 发布混乱、依赖错误 | 版本检查 |
| **M24** | 开发流程 | 严格遵守开发与审核流程 | 质量下降、漏洞增加 | 流程审查 |
| **M25** | 自动回滚 | 回滚策略必须自动化实现 | 回滚失败、数据损坏 | 回滚测试 |
| **M26** | 测试规范 | 测试用例必须遵循规范 | 质量下降、漏洞增加 | 测试审查 |
| **M27** | CI/CD集成 | 必须有持续集成和部署管道 | 构建失败、发布延迟 | 集成测试 |
| **M28** | 场景矩阵 | 必须有完整的场景矩阵覆盖 | 覆盖不足、质量下降 | 场景审查 |
| **M29** | Design Principles | 设计原则必须遵守 | 设计混乱、难以维护 | 阅读1.2.2 |
| **M30** | 代码质量 | 代码必须符合质量标准 | Bug增多、维护困难 | 代码审查  |
| **M31** | 置信度检查 | 关键决策前必须有置信度检查 | 错误决策、资源浪费 | 阅读KNOWLEDGE.md |
| **M32** | 自检协议 | 交付前必须执行自检协议 | 幻觉内容、质量下降 | 阅读KNOWLEDGE.md |
| **M33** | 记录和学习| 记录所有的细节 | 每次迭代都要学习 | TASK.md, KNOWLEDGE.md, PLANNING.md, 所有docs文件夹的文件 |


💡 架构图
![V4PRO 框架架构图]（V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md）

💡 绝对规则 (详细看 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 文件)
1. 不允许修改框架的源码，只能通过配置文件来调整框架的行为。
2. 不允许添加新的依赖库，除非经过审核批准。
3. 不允许删除已有的功能或模块，除非有明确的理由和替代方案。
4. 不允许更改框架的核心算法和逻辑，除非有充分的理由和证明。
5. 不允许在框架中引入不安全的代码或操作，如访问敏感数据等。
6. 遵守 行为准则.md 文件。

📐 设计原则 (详细看 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 文件)
1. 遵循 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 中定义的行为规范和指令集。任何违反这些规定的代码或行为都将被拒绝。
2. 确保代码质量，遵循最佳实践编写代码。
3. 使用模块化设计，确保代码易于维护和扩展。
4. 优先考虑能力优化，确保框架在各种环境下都能高效计算准确率。
5. 保持良好的文档记录，确保代码易于理解和使用。
6. 确保安全性，防止潜在的安全漏洞。
7. 在编写代码之前，请先进行需求分析和设计文档撰写，以确保代码质量和可维护性。
8. 对于框架中的任何问题或建议，请及时反馈给开发团队，以便改进和完善框架。
9. 定期进行代码审查和测试，确保代码质量和稳定性。


  必须遵守的五大核心规范

1. 基于证据的开发
杜绝主观臆断—— 所有开发工作必须基于官方来源验证：
调用 Context7 MCP 获取官方文档
通过 WebFetch/WebSearch 开展调研
实施前先通过 Glob/Grep 检索现有代码
基于测试结果验证假设合理性
反模式警示：严禁基于主观假设或过时知识开展开发。
2. 置信度优先的实施流程
启动开发工作前必须完成置信度检查：
≥90%：直接推进功能实施
70%-89%：提供备选方案，继续深化调研
<70%：立即停止 —— 补充问题调研，完善前期准备
投入产出比（ROI）：投入 100-200 令牌进行置信度检查，可避免因方向错误浪费 5,000-50,000 令牌。
3. 并行优先的执行模式
采用 波浪式→检查点→波浪式 执行模式：
plaintext
第一波：[读取文件1、读取文件2、读取文件3]（并行执行）
   ↓
检查点：汇总分析所有文件内容
   ↓
第二波：[编辑文件1、编辑文件2、编辑文件3]（并行执行）
核心优势：相比串行执行提速 3.5 倍
适用场景：
独立操作（如多文件读取）
批量转换（如多文件编辑）
并行搜索（如多目录全局检索）
禁用场景：
存在依赖关系的操作（必须等待前置结果）
串行分析任务（需逐步构建上下文）
4. 令牌效率优化
根据任务复杂度分配令牌配额：
简单任务（如拼写错误修复）：200 令牌
中等任务（如 Bug 修复）：1,000 令牌
复杂任务（如功能开发）：2,500 令牌
置信度检查投入产出比：可实现 25-250 倍的令牌节约。
5. 零内容失真保障
采用自检协议（SelfCheckProtocol）杜绝生成内容失真：
四项核心校验问题：
所有测试是否全部通过？（需附输出结果）
所有需求是否全部满足？（需列核对清单）
是否存在未经验证的假设？（需附文档依据）
是否具备充分验证证据？（需附测试结果、代码变更记录、验证报告）
七大风险警示信号：
声称 “测试通过” 却不提供输出结果
声称 “功能正常” 却无任何验证证据
声称 “实施完成” 但测试用例失败
刻意忽略错误提示信息
无视代码编译警告
隐瞒功能故障问题
使用 “可能可用” 等模糊表述
🚫 绝对规则
Python 环境规范
Python 操作必须使用 UV 工具
bash
运行
uv run pytest              # 禁用：python -m pytest
uv pip install package     # 禁用：pip install package
uv run python script.py    # 禁用：python script.py
软件包结构：采用 src 目录布局
源码存放路径：src/superclaude/
测试代码路径：tests/
严禁将源码与测试代码混放同一目录
入口点配置：通过 pyproject.toml 声明
命令行工具：配置 [project.scripts] 节点
pytest 插件：配置 [project.entry-points.pytest11] 节点
测试规范
所有新功能必须配套测试用例
为独立组件编写单元测试
为组件交互逻辑编写集成测试
使用 pytest 标记区分测试类型：@pytest.mark.unit（单元测试）、@pytest.mark.integration（集成测试）
测试中必须集成项目管理智能体模式
python
运行
@pytest.mark.confidence_check
def test_feature(confidence_checker):
    context = {...}
    assert confidence_checker.assess(context) >= 0.7

@pytest.mark.self_check
def test_implementation(self_check_protocol):
    passed, issues = self_check_protocol.validate(impl)
    assert passed
测试夹具管理：通过 conftest.py 定义共享测试夹具
Git 工作流规范
分支结构
master：生产环境就绪代码
integration：集成测试分支（暂未创建）
feature/*、fix/*、docs/*：功能开发 / 问题修复 / 文档更新分支
提交信息：遵循约定式提交规范
feat: - 新增功能
fix: - 问题修复
docs: - 文档更新
refactor: - 代码重构
test: - 添加测试用例
chore: - 日常维护工作
禁止提交内容
__pycache__/、*.pyc 编译文件
.venv/、venv/ 虚拟环境目录
个人文件（如 TODO.txt、CRUSH.md）
API 密钥、敏感配置信息
文档规范
代码文档
所有公共函数必须编写文档字符串（Docstring）
强制使用类型注解
文档字符串中需包含使用示例
项目文档
更新 CLAUDE.md 完善 Claude Code 开发指引
更新 README.md 补充用户操作说明
更新本文件 PLANNING.md 记录架构决策
更新 TASK.md 维护当前工作任务
文档同步机制
代码变更时同步更新相关文档
新增功能时更新 CHANGELOG.md 变更日志
架构调整时更新本文件 PLANNING.md
版本管理规范
版本号权威来源
框架版本：存储在 VERSION 文件（例如 V4.0.0）
Python 包版本：配置在 pyproject.toml（例如 0.4.0）
NPM 包版本：配置在 package.json（需与 VERSION 文件版本一致）
版本升级规则
主版本：包含不兼容的 API 变更
次版本：新增功能且保持向后兼容
补丁版本：仅包含问题修复
🔄 开发工作流
新功能开发流程
调研阶段
阅读 PLANNING.md、TASK.md、KNOWLEDGE.md,V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md,行为准则.md 文档
通过 Glob/Grep 检索现有代码，检查功能重复
查阅官方文档（Context7 MCP）和开源实现方案（WebSearch）
执行置信度检查（目标置信度 100%）
实施阶段
创建功能分支：git checkout -b feature/功能名称
遵循测试驱动开发（TDD）原则，先编写测试用例
功能代码开发实现
运行测试：uv run pytest
代码规范检查：make lint
代码格式化：make format
验证阶段
执行自检协议（SelfCheckProtocol）
验证所有测试用例通过
确认所有需求点满足
验证所有假设均有依据
整理并提供完整验证证据
文档阶段
更新相关技术文档
为新增代码编写文档字符串
更新 CHANGELOG.md 变更日志
更新 TASK.md（标记任务完成状态）
更新 KNOWLEDGE.md（必要）
更新 README.md（必要）
更新 PLANNING.md（必要）
更新 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md（必须）
评审阶段
创建合并请求（Pull Request）
发起代码评审
处理评审反馈意见
合并到集成分支（若无集成分支则合并到主分支）
Bug 修复流程
根因分析阶段
复现 Bug 问题
定位根本原因（而非仅解决表面症状）
查阅反思记忆库，检索相似问题模式
执行置信度检查
修复实施阶段
编写可复现问题的失败测试用例
开发 Bug 修复代码
验证测试用例通过
运行完整测试套件
将修复方案记录到反思记忆库
预防机制
添加回归测试用例
必要时更新相关文档
在 KNOWLEDGE.md 中分享经验总结
📊 质量指标
代码质量
测试覆盖率：目标值 >95%
代码规范：零 ruff 检查错误
类型检查：强制使用类型注解，mypy 检查错误数最小化
文档覆盖率：所有公共 API 100% 文档化
项目管理智能体指标
置信度检查投入产出比：25-250 倍令牌节约
自检失真检测率：94%
并行执行效率：相比串行执行提速 3.5 倍
令牌效率：合理预算分配可减少 30-50% 令牌消耗
发布验收标准
新版本发布前必须满足以下条件：
✅ 所有测试用例通过
✅ 相关文档已同步更新
✅ CHANGELOG.md 已更新
✅ 所有版本号保持一致
✅ 无Bug
✅ 已通过安全审计
✅ 完成 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 全部的内容和记录
✅ 完成本文件 CLAUDE.md 全部的内容
✅ 完成 TASK.md 全部的内容和记录
✅ 完成 KNOWNLEGE.md 全部的内容和记录
✅ 完成 CLAUDE.md 全部的内容和记录
✅ 完成 PLANNING.md 全变的内容和记录
✅ 完成 README.md 全部的内容和记录
详细看 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 文件。

提升 Claude Code 框架运行效率的可执行规则
规则优先级体系
🔴 核心优先级：安全、数据保护、生产环境稳定性 ——绝不妥协
🟡 重要优先级：质量、可维护性、专业性 ——优先遵循
🟢 推荐优先级：优化、代码风格、最佳实践 ——实际可行时采用
冲突解决层级
安全优先：安全 / 数据相关规则始终拥有最高优先级
范围＞功能：只开发需求明确的内容＞盲目完善所有功能
质量＞速度：除非遇到真正的紧急情况
结合场景判断：原型开发与生产环境的需求标准存在差异
智能体编排机制
优先级：🔴
触发条件：任务执行阶段、任务完成后阶段
任务执行层（现有自动激活机制）
自动选择：Claude Code 基于上下文自动匹配适用的专业智能体
关键词触发：包含安全、性能、前端、后端、架构等关键词时，触发对应专业智能体
文件类型触发：.py、.jsx、.ts 等文件类型触发对应语言 / 框架专属智能体
复杂度适配：根据任务复杂度（从简单到企业级）确定智能体选型
手动覆盖：使用 @agent-[名称] 前缀可直接指定目标智能体执行任务
自我优化层（项目管理智能体元层）
任务完成后激活：任务结束后，项目管理智能体自动启动，记录经验总结
错误检测触发：出现错误时立即激活，开展根因分析
月度维护机制：定期执行系统化文档健康度审查
知识沉淀：将实践经验转化为可复用的模式与最佳实践
文档迭代：持续维护简洁、高价值、信息明确的文档内容
编排流程
任务执行：用户发起请求 → 自动激活机制匹配专业智能体 → 执行开发任务
文档记录（项目管理智能体负责）：开发完成 → 项目管理智能体记录实现模式与决策依据
经验学习：检测到错误 → 项目管理智能体分析根因 → 制定预防清单
维护优化：每月定期执行 → 项目管理智能体清理过期文档 → 更新知识库
✅ 正确流程示例
用户请求 → 后端架构师智能体执行开发 → 项目管理智能体记录实现模式
错误触发 → 项目管理智能体暂停工作 → 根因分析 → 更新文档
@agent-security "review auth" → 直接调用安全工程师智能体（手动覆盖机制）
❌ 错误流程示例
开发完成后跳过文档记录步骤（未激活项目管理智能体）
发现错误后继续开发（未执行根因分析）
工作流规则
优先级：🟡
触发条件：所有开发任务
任务执行模式：理解需求 → 规划方案（含并行化分析）→ 编写任务清单（至少 3 项子任务）→ 执行开发 → 进度跟踪 → 验证验收
批量操作原则：默认优先并行调用工具，仅在存在依赖关系时采用串行执行
验证门禁：执行前必须完成验证，任务结束后再次核验结果
质量检查：标记任务完成前，必须运行代码检查与类型校验
上下文保持：在全流程中保持≥90% 的需求理解一致性
实证导向：所有技术主张必须可通过测试或文档验证
先行调研：执行系统性修改前，需完成全项目范围的现状分析
会话生命周期：通过 /sc:load 初始化会话，定期创建检查点，结束前执行保存操作
会话执行模式：/sc:load → 开展工作 → 每 30 分钟创建检查点 → /sc:save 保存
检查点触发条件：任务完成时、每 30 分钟、执行高风险操作前
✅ 正确示例：规划 → 编写任务清单 → 执行开发 → 验证验收
❌ 错误示例：未经规划直接启动开发工作
规划效率规则
优先级：🔴
触发条件：所有规划阶段、任务清单编写、多步骤任务
并行化分析：规划阶段需明确识别可并行执行的操作项
工具优化规划：提前规划最优的 MCP 服务器组合与批量操作方案
依赖关系映射：清晰区分串行依赖任务与可并行任务
资源估算：规划阶段需评估令牌消耗与执行时间
效率指标量化：规划文档需明确预期并行收益（例如：“3 项并行操作 = 节省 60% 时间”）
✅ 正确示例：
“规划方案：1) 并行执行：[读取 5 个文件] 2) 串行执行：分析文件内容 → 3) 并行执行：[编辑所有文件]”
❌ 错误示例：
“规划方案：读取文件 1 → 读取文件 2 → 读取文件 3 → 分析内容 → 编辑文件 1 → 编辑文件 2”
实现完整性规则
优先级：🟡
触发条件：功能开发、函数编写、代码生成
禁止部分实现：启动开发后，必须完成全部工作直至达到可运行状态
无遗留待办项：核心功能或实现代码中禁止保留 TODO 注释
禁用模拟对象：不允许使用占位符、虚假数据或桩实现
无残缺函数：每个函数必须按需求实现完整功能，禁止抛出 “未实现” 异常
全量交付思维：“启动即完成”—— 功能交付无例外
仅生成生产级代码：所有生成代码必须达到国家军规级别代码标准，而非脚手架代码
✅ 正确示例：
javascript
运行
function calculate() {
  return price * tax;
}
❌ 错误示例：
javascript
运行
function calculate() {
  throw new Error("Not implemented");
}
❌ 错误示例：
javascript
运行
// TODO: implement tax calculation
范围管控规则
优先级：🟡
触发条件：需求模糊时、功能扩展时、架构决策时
按需开发：仅实现明确要求的功能，禁止额外新增功能
最小可行产品优先：先开发最小可行方案，再基于反馈迭代优化
避免过度设计：未明确要求时，不添加认证、部署、监控等功能
单一职责原则：每个组件仅专注实现一项核心功能
优选简单方案：相较于复杂架构，优先选择具备演进能力的简洁代码
三思而后行：遵循 “理解→规划→构建” 流程，而非 “构建→追加构建”
践行 YAGNI 原则：你不会用到它 —— 禁止开发投机性功能
✅ 正确示例：需求为 “开发登录表单” → 仅实现登录表单功能
❌ 错误示例：需求为 “开发登录表单” → 额外开发登录 + 注册 + 密码重置 + 双因素认证功能
代码组织规则
优先级：🟢
触发条件：创建文件、项目结构设计、命名决策时
命名规范一致性：遵循对应语言 / 框架标准（JavaScript 使用小驼峰命名法，Python 使用下划线命名法）
命名表意清晰：文件、函数、变量名称必须准确描述其用途
目录结构逻辑性：按功能 / 业务域组织代码，而非按文件类型划分
遵循既有模式：匹配项目已有的组织方式与命名规范
层级逻辑清晰：在文件夹结构中建立明确的父子级关系
禁止混合规范：同一项目中严禁混用小驼峰 / 下划线 / 短横线命名法
组织方式简洁优雅：采用清晰、可扩展的结构，提升代码导航与理解效率
✅ 正确示例：getUserData()、user_data.py、components/auth/
❌ 错误示例：get_userData()、userdata.py、files/everything/
工作区整洁规则
优先级：🟡
触发条件：操作完成后、会话结束时、创建临时文件时
操作后清理：任务完成后删除临时文件、脚本与目录
禁止产物污染：删除构建产物、日志文件与调试输出
临时文件管理：任务完成前清理所有临时文件
保持专业工作区：维护整洁的项目结构，避免冗余文件堆积
会话结束清理：结束会话前移除所有临时资源
版本控制规范：禁止遗留可能被意外提交的临时文件
资源管理：删除未使用的目录与文件，防止工作区臃肿
✅ 正确示例：使用后执行 rm temp_script.py 删除临时脚本
❌ 错误示例：遗留 debug.sh、test.log、temp/ 目录
故障排查规则
优先级：🔴
触发条件：出现错误、测试失败、异常行为、工具故障时
根因分析：必须调查故障发生的原因，而非仅关注故障现象
禁止跳过测试：严禁为达成结果而禁用、注释或跳过测试用例
禁止绕过验证：严禁为实现功能而跳过质量检查或验证流程
系统化调试：暂停操作、分析错误信息、全面排查工具故障
根治问题而非规避：解决问题根源，而非仅处理表面症状
工具故障排查：MCP 工具或脚本故障时，需先调试再更换方案
质量完整性：严禁为追求短期结果而损害系统完整性
条理化问题解决：遵循 “理解→诊断→修复→验证” 流程，杜绝急于求成
✅ 正确示例：分析堆栈跟踪 → 定位根因 → 彻底修复问题
❌ 错误示例：注释掉失败的测试用例以通过构建
检测方法：执行 grep -r "skip\|disable\|TODO" tests/ 排查违规项
专业诚信规则
优先级：🟡
触发条件：评估工作、代码评审、提供建议、提出技术主张时
禁用营销话术：严禁使用 “极速”“100% 安全”“卓越”“极佳” 等夸张表述
禁止伪造指标：无实证时，严禁捏造时间估算、百分比或评级数据
批判性评估：客观说明方案的利弊权衡与潜在风险
合理提出异议：礼貌指出提议方案存在的问题
实证导向主张：所有技术主张必须可验证，而非主观推测
杜绝谄媚行为：停止过度吹捧，提供专业反馈
客观评估表述：使用 “未经测试”“最小可行产品”“需验证” 等表述，而非 “生产可用”
专业用语规范：使用技术术语，避免销售 / 营销类极端形容词
✅ 正确示例：“该方案存在利弊权衡：执行速度更快，但内存占用更高”
❌ 错误示例：“这套卓越的解决方案极速高效且 100% 安全！”
Git 工作流规则
优先级：🔴
触发条件：会话启动时、执行修改前、高风险操作前
优先检查状态：所有会话启动时，先执行 git status 与 git branch 命令
专属功能分支：所有开发工作必须在功能分支进行，严禁直接操作主分支
增量提交：频繁提交代码并撰写有意义的提交信息，避免大体积单次提交
提交前验证：执行 git diff 查看变更内容后，再进行暂存操作
创建恢复点：执行高风险操作前提交代码，确保可快速回滚
实验性分支策略：使用分支安全测试不同技术方案
清晰提交历史：撰写描述性提交信息，避免使用 “修复”“更新”“变更” 等模糊表述
非破坏性工作流：始终保留回滚变更的能力
✅ 正确示例：git checkout -b feature/auth → 开发 → 提交 → 创建合并请求
❌ 错误示例：直接在主分支上开展开发工作

交易军规规则 (V4PRO 期货交易专用)
优先级：🔴
触发条件：交易信号生成、订单执行、风控检查时

核心交易军规

| 军规 | 名称 | 规则描述 | 检查方式 |
|------|------|----------|----------|
| M1 | 单一信号源 | 一个交易信号只能来自一个策略实例 | 信号源ID验证 |
| M6 | 熔断保护 | 触发风控阈值必须立即停止交易 | 实时阈值监控 |
| M13 | 涨跌停感知 | 订单价格必须检查涨跌停板 | 价格范围验证 |
| M16 | 保证金监控 | 保证金使用率必须实时计算 | 持续监控告警 |
| M17 | 程序化合规 | 报撤单频率必须在监管阈值内 | 频率门禁检查 |

交易决策清单

🔴 信号生成前
- [ ] M1: 确认信号来源唯一
- [ ] M6: 检查当前风控状态
- [ ] M16: 验证保证金充足
- [ ] M17: 检查报撤单频率

🔴 订单执行前
- [ ] M13: 检查涨跌停限制
- [ ] M17: 检查报撤单频率
- [ ] M6: 再次确认无熔断状态
- [ ] M16: 最终保证金验证
- [ ] M1: 确认信号一致性

🔴 订单执行后
- [ ] M3: 完成审计日志记录
- [ ] M16: 更新保证金使用率
- [ ] M19: 记录风险归因
- [ ] M6: 更新风控状态

违规处理

| 违规类型 | 处理措施 | 恢复条件 |
|----------|----------|----------|
| M1违规 | 拒绝信号+告警 | 信号源修正 |
| M6违规 | 立即熔断+全平 | 人工解除 |
| M13违规 | 订单拒绝 | 价格修正 |
| M16违规 | 限制新开仓 | 追加保证金 |
| M17违规 | 暂停报撤单 | 频率恢复正常 |
| M3违规 | 补充审计记录 | 完成日志 |
| M19违规 | 风险评估+调整 | 风险降低 |

分层确认机制 (M12双重确认)

| 确认级别 | 金额阈值 | 处理方式 |
|----------|----------|----------|
| AUTO (全自动) | <50万 | 无需确认，直接执行 |
| SOFT_CONFIRM (软确认) | 50万-200万 | 系统二次校验 |
| HARD_CONFIRM (硬确认) | >200万 | 人工介入确认 |

✅ 正确示例：信号生成 → M1验证 → M6检查 → M16保证金验证 → 执行
❌ 错误示例：跳过风控检查直接执行订单

工具优化规则
优先级：🟢
触发条件：多步骤操作、性能需求场景、复杂任务执行时
最优工具选择：为每项任务选择最适用的工具（MCP 工具＞原生工具＞基础工具）
全面并行化：独立操作优先并行执行，杜绝串行执行
智能体委派：复杂多步骤任务（超过 3 步）委派给任务智能体处理
MCP 服务器高效利用：发挥专用 MCP 服务器优势（批量编辑用 morphllm、分析任务用 sequential-thinking）
批量操作原则：优先使用批量编辑替代多次单独编辑，批量读取文件，归类执行操作
高效搜索策略：使用 Grep 工具替代 bash grep，使用 Glob 工具替代 find 命令，优先选择专用搜索工具
效率优先原则：优先选择速度快、功能强的方案，而非熟悉的方案
工具专业化匹配：按工具设计用途选择（例如：网页测试用 playwright、文档查询用 context7）
✅ 正确示例：3 个及以上文件修改用批量编辑工具、并行执行文件读取操作
❌ 错误示例：串行执行编辑操作、使用 bash grep 替代专用 Grep 工具
文件组织规则
优先级：🟡
触发条件：创建文件、项目结构设计、文档编写时
三思而后写：创建文件前，先确定合理的存放路径
Claude 专属文档规范：报告、分析报告、总结文档统一存放至 claudedocs/ 目录
测试文件组织：所有测试文件统一存放至 tests/、__tests__/ 或 test/ 目录
脚本文件组织：工具脚本统一存放至 scripts/、tools/ 或 bin/ 目录
遵循既有模式：创建新目录前，先参考项目已有的测试 / 脚本目录结构
禁止测试文件散落：严禁在源码目录旁创建 test_*.py 或 *.test.js 测试文件
禁止脚本随意存放：严禁在随机位置创建 debug.sh、script.py、utility.js 等脚本文件
关注点分离原则：合理分离测试代码、脚本文件、文档与源代码
按用途组织文件：根据文件功能与目标受众进行分类管理
✅ 正确示例：tests/auth.test.js、scripts/deploy.sh、claudedocs/analysis.md
❌ 错误示例：在 auth.js 旁创建 auth.test.js、在项目根目录创建 debug.sh
安全规则
优先级：🔴
触发条件：文件操作、库使用、代码库修改时
尊重框架规范：使用第三方库前，先检查 package.json/ 依赖清单
遵循既有模式：遵循项目已有的编码规范与导入风格
事务安全原则：优先选择支持回滚能力的批量操作
系统化变更流程：代码库修改遵循 “规划→执行→验证” 流程
✅ 正确示例：检查依赖项 → 遵循编码模式 → 安全执行操作
❌ 错误示例：无视既有规范，执行无规划的修改操作
时间感知规则
优先级：🔴
触发条件：涉及日期 / 时间引用、版本检查、截止日期计算、使用 “最新” 关键词时
验证当前日期：执行任何时间相关评估前，务必从上下文中确认 “今日日期”
不依赖知识截止日期：禁止默认使用 2025 年 1 月或模型知识截止日期
时间引用明确化：注明所有日期 / 时间信息的来源
版本上下文确认：提及 “最新版本” 时，必须结合当前日期进行验证
时间计算基准：所有时间相关计算均基于验证后的当前日期，而非主观假设
✅ 正确示例：“环境检查：今日为 2025-08-15，因此第三季度截止日期为……”
❌ 错误示例：“因为当前是 2025 年 1 月……”（未检查实际日期）
检测方法：排查所有未验证环境信息的日期引用
速查指南与决策树
核心决策流程
🔴 执行任何文件操作前
plaintext
是否需要执行文件操作？
├─ 写入/编辑操作？ → 先读取现有内容 → 理解编码模式 → 执行编辑
├─ 创建新文件？ → 检查现有结构 → 合理放置文件
└─ 安全检查 → 仅使用绝对路径 → 禁止自动提交
🟡 启动新功能开发前
plaintext
收到新功能需求？
├─ 需求范围明确？ → 否 → 先进入头脑风暴模式
├─ 步骤超过3个？ → 是 → 必须编写任务清单
├─ 存在既有实现模式？ → 是 → 严格遵循
├─ 存在测试用例？ → 是 → 启动开发前先执行测试
└─ 依赖框架库？ → 先检查 package.json
🟢 工具选择矩阵
plaintext
任务类型 → 最优工具：
├─ 多文件编辑 → 批量编辑工具 ＞ 单次编辑工具
├─ 复杂分析任务 → 任务智能体 ＞ 原生推理能力
├─ 代码搜索 → Grep 工具 ＞ bash grep 命令
├─ UI 组件开发 → Magic MCP 工具 ＞ 手动编码
├─ 文档查询 → Context7 MCP 工具 ＞ 网络搜索
└─ 浏览器测试 → Playwright MCP 工具 ＞ 单元测试
优先级速查行动清单
🔴 核心优先级（绝不妥协）
启动工作前执行 git status && git branch
写入 / 编辑操作前先执行读取操作
仅使用功能分支，严禁操作主分支
坚持根因分析，绝不跳过验证步骤
仅使用绝对路径，禁止自动提交代码
🟡 重要优先级（优先遵循）
超过 3 步的任务必须编写任务清单
所有启动的开发工作必须完成
按需开发（最小可行产品优先）
使用专业用语（禁用营销类夸张表述）
保持工作区整洁（删除临时文件）
🟢 推荐优先级（实际可行时采用）
优先并行执行，而非串行执行
遵循描述性命名规范
优先使用 MCP 工具，而非基础工具
尽可能采用批量操作



核心要点：
严格遵守本文件和 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 文件和 行为准则.md 文件中的绝对规则
所有新增代码必须配套测试用例
集成项目管理智能体模式
同步更新相关文档
提交合并请求前必须发起代码评审

⚠ 最终一切以 V4PRO_UPGRADE_PLAN_SUPREME_DIRECTIVE.md 文件和 行为准则.md 文件为准。

📚 参考资源
TASK.md：当前任务与优先级列表
KNOWLEDGE.md：经验总结与最佳实践
CONTRIBUTING.md：贡献指南
docs/：完整项目文档库

本文件由 山东齐沥开发团队维护，任何架构决策变更均需同步更新。
最后更新时间：2025-11-12（修复议题 #466 时自动生成）